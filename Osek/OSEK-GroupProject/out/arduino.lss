
arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000c8  00800100  00000dca  00000e5e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dca  00000000  00000000  00000094  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000ae  008001c8  008001c8  00000f26  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00000f26  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f38  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000480  00000000  00000000  00000f78  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d26d  00000000  00000000  000013f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000254d  00000000  00000000  0000e665  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002d25  00000000  00000000  00010bb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b10  00000000  00000000  000138d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003556  00000000  00000000  000143e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000443a  00000000  00000000  0001793e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000520  00000000  00000000  0001bd78  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 42 01 	jmp	0x284	; 0x284 <__vector_16>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 03 03 	jmp	0x606	; 0x606 <__vector_18>
  4c:	0c 94 35 03 	jmp	0x66a	; 0x66a <__vector_19>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
  68:	65 03       	mulsu	r22, r21

0000006a <__ctors_end>:
  6a:	11 24       	eor	r1, r1
  6c:	1f be       	out	0x3f, r1	; 63
  6e:	cf ef       	ldi	r28, 0xFF	; 255
  70:	d8 e0       	ldi	r29, 0x08	; 8
  72:	de bf       	out	0x3e, r29	; 62
  74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	a0 e0       	ldi	r26, 0x00	; 0
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	ea ec       	ldi	r30, 0xCA	; 202
  7e:	fd e0       	ldi	r31, 0x0D	; 13
  80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
  82:	05 90       	lpm	r0, Z+
  84:	0d 92       	st	X+, r0
  86:	a8 3c       	cpi	r26, 0xC8	; 200
  88:	b1 07       	cpc	r27, r17
  8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
  8c:	22 e0       	ldi	r18, 0x02	; 2
  8e:	a8 ec       	ldi	r26, 0xC8	; 200
  90:	b1 e0       	ldi	r27, 0x01	; 1
  92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
  96:	a6 37       	cpi	r26, 0x76	; 118
  98:	b2 07       	cpc	r27, r18
  9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	c5 e3       	ldi	r28, 0x35	; 53
  a0:	d0 e0       	ldi	r29, 0x00	; 0
  a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
  a4:	21 97       	sbiw	r28, 0x01	; 1
  a6:	fe 01       	movw	r30, r28
  a8:	0e 94 dd 06 	call	0xdba	; 0xdba <__tablejump2__>
  ac:	c4 33       	cpi	r28, 0x34	; 52
  ae:	d1 07       	cpc	r29, r17
  b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
  b2:	0e 94 24 01 	call	0x248	; 0x248 <main>
  b6:	0c 94 e3 06 	jmp	0xdc6	; 0xdc6 <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 6b 06 	jmp	0xcd6	; 0xcd6 <__vector_default>
	...

000000c0 <osEE_hal_save_ctx_and_restore_ctx>:
  .type osEE_hal_save_ctx_and_restore_ctx, @function
osEE_hal_save_ctx_and_restore_ctx:
  /*  r25:r24 parameter:  OsEE_TDB * p_to_tdb
      r23:r22 parameter:  OsEE_SCB * p_to_scb
      r21:r20 parameter:  OsEE_SCB * p_from_scb */
    osEE_hal_save_vcontext_m r21 r20
  c0:	2f 92       	push	r2
  c2:	3f 92       	push	r3
  c4:	4f 92       	push	r4
  c6:	5f 92       	push	r5
  c8:	6f 92       	push	r6
  ca:	7f 92       	push	r7
  cc:	8f 92       	push	r8
  ce:	9f 92       	push	r9
  d0:	af 92       	push	r10
  d2:	bf 92       	push	r11
  d4:	cf 92       	push	r12
  d6:	df 92       	push	r13
  d8:	ef 92       	push	r14
  da:	ff 92       	push	r15
  dc:	0f 93       	push	r16
  de:	1f 93       	push	r17
  e0:	cf 93       	push	r28
  e2:	df 93       	push	r29
  e4:	e4 2f       	mov	r30, r20
  e6:	f5 2f       	mov	r31, r21
  e8:	41 90       	ld	r4, Z+
  ea:	50 80       	ld	r5, Z
  ec:	4f 92       	push	r4
  ee:	5f 92       	push	r5
  f0:	e4 2f       	mov	r30, r20
  f2:	f5 2f       	mov	r31, r21
  f4:	4d b6       	in	r4, 0x3d	; 61
  f6:	5e b6       	in	r5, 0x3e	; 62
  f8:	41 92       	st	Z+, r4
  fa:	50 82       	st	Z, r5

/* Unconditional brach to restore context */
    jmp osEE_hal_restore_ctx
  fc:	0c 94 80 00 	jmp	0x100	; 0x100 <osEE_hal_restore_ctx>

00000100 <osEE_hal_restore_ctx>:
  .globl osEE_hal_restore_ctx
  .type osEE_hal_restore_ctx, @function
osEE_hal_restore_ctx:
  /*  r25:r24 parameter:  OsEE_TDB * p_to_tdb
      r23:r22 parameter:  OsEE_SCB * p_to_scb */
    osEE_hal_restore_vcontext_m r23 r22
 100:	e6 2f       	mov	r30, r22
 102:	f7 2f       	mov	r31, r23
 104:	41 90       	ld	r4, Z+
 106:	50 80       	ld	r5, Z
 108:	4d be       	out	0x3d, r4	; 61
 10a:	5e be       	out	0x3e, r5	; 62
 10c:	5f 90       	pop	r5
 10e:	4f 90       	pop	r4
 110:	e6 2f       	mov	r30, r22
 112:	f7 2f       	mov	r31, r23
 114:	41 92       	st	Z+, r4
 116:	50 82       	st	Z, r5
 118:	df 91       	pop	r29
 11a:	cf 91       	pop	r28
 11c:	1f 91       	pop	r17
 11e:	0f 91       	pop	r16
 120:	ff 90       	pop	r15
 122:	ef 90       	pop	r14
 124:	df 90       	pop	r13
 126:	cf 90       	pop	r12
 128:	bf 90       	pop	r11
 12a:	af 90       	pop	r10
 12c:	9f 90       	pop	r9
 12e:	8f 90       	pop	r8
 130:	7f 90       	pop	r7
 132:	6f 90       	pop	r6
 134:	5f 90       	pop	r5
 136:	4f 90       	pop	r4
 138:	3f 90       	pop	r3
 13a:	2f 90       	pop	r2
    jmp osEE_scheduler_task_wrapper_restore
 13c:	0c 94 c0 04 	jmp	0x980	; 0x980 <osEE_scheduler_task_wrapper_restore>

00000140 <osEE_hal_ready2stacked>:
  .type   osEE_hal_ready2stacked, @function
osEE_hal_ready2stacked:
  /*  r25:r24 parameter:  OsEE_TDB * p_to_tdb
      r23:r22 parameter:  OsEE_SCB * p_to_scb
      r21:r20 local       p_to_scb->p_tos */
    mov r30, r22
 140:	e6 2f       	mov	r30, r22
    mov r31, r23
 142:	f7 2f       	mov	r31, r23
    ld  r20, z+
 144:	41 91       	ld	r20, Z+
    ld  r21, z
 146:	50 81       	ld	r21, Z
/* sp = 21:20 */
    out 0x3D, r20
 148:	4d bf       	out	0x3d, r20	; 61
    out 0x3E, r21
 14a:	5e bf       	out	0x3e, r21	; 62

    jmp osEE_scheduler_task_wrapper_run
 14c:	0c 94 c1 04 	jmp	0x982	; 0x982 <osEE_scheduler_task_wrapper_run>

00000150 <osEE_hal_save_ctx_and_ready2stacked>:
  .type osEE_hal_save_ctx_and_ready2stacked, @function
osEE_hal_save_ctx_and_ready2stacked:
  /*  r25:r24 parameter:  OsEE_TDB * p_to_tdb
      r23:r22 parameter:  OsEE_SCB * p_to_scb
      r21:r20 parameter:  OsEE_SCB * p_from_scb */
    osEE_hal_save_vcontext_m r21 r20
 150:	2f 92       	push	r2
 152:	3f 92       	push	r3
 154:	4f 92       	push	r4
 156:	5f 92       	push	r5
 158:	6f 92       	push	r6
 15a:	7f 92       	push	r7
 15c:	8f 92       	push	r8
 15e:	9f 92       	push	r9
 160:	af 92       	push	r10
 162:	bf 92       	push	r11
 164:	cf 92       	push	r12
 166:	df 92       	push	r13
 168:	ef 92       	push	r14
 16a:	ff 92       	push	r15
 16c:	0f 93       	push	r16
 16e:	1f 93       	push	r17
 170:	cf 93       	push	r28
 172:	df 93       	push	r29
 174:	e4 2f       	mov	r30, r20
 176:	f5 2f       	mov	r31, r21
 178:	41 90       	ld	r4, Z+
 17a:	50 80       	ld	r5, Z
 17c:	4f 92       	push	r4
 17e:	5f 92       	push	r5
 180:	e4 2f       	mov	r30, r20
 182:	f5 2f       	mov	r31, r21
 184:	4d b6       	in	r4, 0x3d	; 61
 186:	5e b6       	in	r5, 0x3e	; 62
 188:	41 92       	st	Z+, r4
 18a:	50 82       	st	Z, r5
    jmp osEE_hal_ready2stacked
 18c:	0c 94 a0 00 	jmp	0x140	; 0x140 <osEE_hal_ready2stacked>

00000190 <osEE_hal_terminate_ctx>:
  .type osEE_hal_terminate_ctx, @function
osEE_hal_terminate_ctx:
  /*  r25:r24 parameter:  OsEE_SCB * p_term_scb
      r23:r22 parameter:  kernel_cb
      r21:r20 local       p_term_scb->p_tos */
    mov r30, r24
 190:	e8 2f       	mov	r30, r24
    mov r31, r25
 192:	f9 2f       	mov	r31, r25
    ld  r20, z+
 194:	41 91       	ld	r20, Z+
    ld  r21, z
 196:	50 81       	ld	r21, Z

/* Unwind SP */
    out 0x3D, r20 /* r20 -> spl */
 198:	4d bf       	out	0x3d, r20	; 61
    out 0x3E, r21 /* r21 -> sph */
 19a:	5e bf       	out	0x3e, r21	; 62

/*  Jump to kern_callback (that schedule) */
    mov r30, r22
 19c:	e6 2f       	mov	r30, r22
    mov r31, r23
 19e:	f7 2f       	mov	r31, r23

    ijmp
 1a0:	09 94       	ijmp
	...

000001a4 <StartupHook>:
 1a4:	08 95       	ret

000001a6 <idle_hook>:
 1a6:	0f 93       	push	r16
 1a8:	1f 93       	push	r17
 1aa:	cf 93       	push	r28
 1ac:	df 93       	push	r29
 1ae:	00 d0       	rcall	.+0      	; 0x1b0 <idle_hook+0xa>
 1b0:	cd b7       	in	r28, 0x3d	; 61
 1b2:	de b7       	in	r29, 0x3e	; 62
 1b4:	8d b7       	in	r24, 0x3d	; 61
 1b6:	9e b7       	in	r25, 0x3e	; 62
 1b8:	9a 83       	std	Y+2, r25	; 0x02
 1ba:	89 83       	std	Y+1, r24	; 0x01
 1bc:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <__data_end>
 1c0:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <__data_end+0x1>
 1c4:	89 2b       	or	r24, r25
 1c6:	a9 f4       	brne	.+42     	; 0x1f2 <idle_hook+0x4c>
 1c8:	89 81       	ldd	r24, Y+1	; 0x01
 1ca:	9a 81       	ldd	r25, Y+2	; 0x02
 1cc:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <__data_end+0x1>
 1d0:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <__data_end>
 1d4:	f8 94       	cli
 1d6:	84 e0       	ldi	r24, 0x04	; 4
 1d8:	92 e0       	ldi	r25, 0x02	; 2
 1da:	89 2b       	or	r24, r25
 1dc:	11 f0       	breq	.+4      	; 0x1e2 <idle_hook+0x3c>
 1de:	0e 94 04 02 	call	0x408	; 0x408 <_Z14serialEventRunv>
 1e2:	78 94       	sei
 1e4:	0f 90       	pop	r0
 1e6:	0f 90       	pop	r0
 1e8:	df 91       	pop	r29
 1ea:	cf 91       	pop	r28
 1ec:	1f 91       	pop	r17
 1ee:	0f 91       	pop	r16
 1f0:	08 95       	ret
 1f2:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <__data_end>
 1f6:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <__data_end+0x1>
 1fa:	89 81       	ldd	r24, Y+1	; 0x01
 1fc:	9a 81       	ldd	r25, Y+2	; 0x02
 1fe:	28 17       	cp	r18, r24
 200:	39 07       	cpc	r19, r25
 202:	41 f3       	breq	.-48     	; 0x1d4 <idle_hook+0x2e>
 204:	f8 94       	cli
 206:	8c e2       	ldi	r24, 0x2C	; 44
 208:	91 e0       	ldi	r25, 0x01	; 1
 20a:	0e 94 2e 01 	call	0x25c	; 0x25c <serial_print>
 20e:	04 e0       	ldi	r16, 0x04	; 4
 210:	12 e0       	ldi	r17, 0x02	; 2
 212:	01 15       	cp	r16, r1
 214:	11 05       	cpc	r17, r1
 216:	e9 f3       	breq	.-6      	; 0x212 <idle_hook+0x6c>
 218:	0e 94 04 02 	call	0x408	; 0x408 <_Z14serialEventRunv>
 21c:	fa cf       	rjmp	.-12     	; 0x212 <idle_hook+0x6c>

0000021e <setup>:
 21e:	e9 e6       	ldi	r30, 0x69	; 105
 220:	f0 e0       	ldi	r31, 0x00	; 0
 222:	80 81       	ld	r24, Z
 224:	82 60       	ori	r24, 0x02	; 2
 226:	80 83       	st	Z, r24
 228:	e8 9a       	sbi	0x1d, 0	; 29
 22a:	26 e0       	ldi	r18, 0x06	; 6
 22c:	40 e0       	ldi	r20, 0x00	; 0
 22e:	52 ec       	ldi	r21, 0xC2	; 194
 230:	61 e0       	ldi	r22, 0x01	; 1
 232:	70 e0       	ldi	r23, 0x00	; 0
 234:	85 ed       	ldi	r24, 0xD5	; 213
 236:	91 e0       	ldi	r25, 0x01	; 1
 238:	0e 94 a1 02 	call	0x542	; 0x542 <_ZN14HardwareSerial5beginEmh>
 23c:	68 e4       	ldi	r22, 0x48	; 72
 23e:	71 e0       	ldi	r23, 0x01	; 1
 240:	85 ed       	ldi	r24, 0xD5	; 213
 242:	91 e0       	ldi	r25, 0x01	; 1
 244:	0c 94 d2 03 	jmp	0x7a4	; 0x7a4 <_ZN5Print7printlnEPKc>

00000248 <main>:
 248:	0e 94 8c 01 	call	0x318	; 0x318 <init>
 24c:	0e 94 0f 01 	call	0x21e	; 0x21e <setup>
 250:	80 e0       	ldi	r24, 0x00	; 0
 252:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <StartOS>
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	80 e0       	ldi	r24, 0x00	; 0
 25a:	08 95       	ret

0000025c <serial_print>:
 25c:	f8 94       	cli
 25e:	fc 01       	movw	r30, r24
 260:	01 90       	ld	r0, Z+
 262:	00 20       	and	r0, r0
 264:	e9 f7       	brne	.-6      	; 0x260 <serial_print+0x4>
 266:	31 97       	sbiw	r30, 0x01	; 1
 268:	af 01       	movw	r20, r30
 26a:	48 1b       	sub	r20, r24
 26c:	59 0b       	sbc	r21, r25
 26e:	bc 01       	movw	r22, r24
 270:	85 ed       	ldi	r24, 0xD5	; 213
 272:	91 e0       	ldi	r25, 0x01	; 1
 274:	0e 94 92 03 	call	0x724	; 0x724 <_ZN5Print5writeEPKhj>
 278:	78 94       	sei
 27a:	08 95       	ret

0000027c <FuncDetectTask>:
 27c:	0c 94 99 04 	jmp	0x932	; 0x932 <TerminateTask>

00000280 <FuncDisplayTask>:
 280:	0c 94 99 04 	jmp	0x932	; 0x932 <TerminateTask>

00000284 <__vector_16>:
	__asm__ __volatile__ (
		"1: sbiw %0,1" "\n\t" // 2 cycles
		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
	);
	// return = 4 cycles
}
 284:	1f 92       	push	r1
 286:	0f 92       	push	r0
 288:	0f b6       	in	r0, 0x3f	; 63
 28a:	0f 92       	push	r0
 28c:	11 24       	eor	r1, r1
 28e:	2f 93       	push	r18
 290:	3f 93       	push	r19
 292:	8f 93       	push	r24
 294:	9f 93       	push	r25
 296:	af 93       	push	r26
 298:	bf 93       	push	r27
 29a:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <timer0_millis>
 29e:	90 91 ce 01 	lds	r25, 0x01CE	; 0x8001ce <timer0_millis+0x1>
 2a2:	a0 91 cf 01 	lds	r26, 0x01CF	; 0x8001cf <timer0_millis+0x2>
 2a6:	b0 91 d0 01 	lds	r27, 0x01D0	; 0x8001d0 <timer0_millis+0x3>
 2aa:	30 91 cc 01 	lds	r19, 0x01CC	; 0x8001cc <timer0_fract>
 2ae:	23 e0       	ldi	r18, 0x03	; 3
 2b0:	23 0f       	add	r18, r19
 2b2:	2d 37       	cpi	r18, 0x7D	; 125
 2b4:	58 f5       	brcc	.+86     	; 0x30c <__vector_16+0x88>
 2b6:	01 96       	adiw	r24, 0x01	; 1
 2b8:	a1 1d       	adc	r26, r1
 2ba:	b1 1d       	adc	r27, r1
 2bc:	20 93 cc 01 	sts	0x01CC, r18	; 0x8001cc <timer0_fract>
 2c0:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <timer0_millis>
 2c4:	90 93 ce 01 	sts	0x01CE, r25	; 0x8001ce <timer0_millis+0x1>
 2c8:	a0 93 cf 01 	sts	0x01CF, r26	; 0x8001cf <timer0_millis+0x2>
 2cc:	b0 93 d0 01 	sts	0x01D0, r27	; 0x8001d0 <timer0_millis+0x3>
 2d0:	80 91 d1 01 	lds	r24, 0x01D1	; 0x8001d1 <timer0_overflow_count>
 2d4:	90 91 d2 01 	lds	r25, 0x01D2	; 0x8001d2 <timer0_overflow_count+0x1>
 2d8:	a0 91 d3 01 	lds	r26, 0x01D3	; 0x8001d3 <timer0_overflow_count+0x2>
 2dc:	b0 91 d4 01 	lds	r27, 0x01D4	; 0x8001d4 <timer0_overflow_count+0x3>
 2e0:	01 96       	adiw	r24, 0x01	; 1
 2e2:	a1 1d       	adc	r26, r1
 2e4:	b1 1d       	adc	r27, r1
 2e6:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <timer0_overflow_count>
 2ea:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <timer0_overflow_count+0x1>
 2ee:	a0 93 d3 01 	sts	0x01D3, r26	; 0x8001d3 <timer0_overflow_count+0x2>
 2f2:	b0 93 d4 01 	sts	0x01D4, r27	; 0x8001d4 <timer0_overflow_count+0x3>
 2f6:	bf 91       	pop	r27
 2f8:	af 91       	pop	r26
 2fa:	9f 91       	pop	r25
 2fc:	8f 91       	pop	r24
 2fe:	3f 91       	pop	r19
 300:	2f 91       	pop	r18
 302:	0f 90       	pop	r0
 304:	0f be       	out	0x3f, r0	; 63
 306:	0f 90       	pop	r0
 308:	1f 90       	pop	r1
 30a:	18 95       	reti
 30c:	26 e8       	ldi	r18, 0x86	; 134
 30e:	23 0f       	add	r18, r19
 310:	02 96       	adiw	r24, 0x02	; 2
 312:	a1 1d       	adc	r26, r1
 314:	b1 1d       	adc	r27, r1
 316:	d2 cf       	rjmp	.-92     	; 0x2bc <__vector_16+0x38>

00000318 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 318:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 31a:	84 b5       	in	r24, 0x24	; 36
 31c:	82 60       	ori	r24, 0x02	; 2
 31e:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 320:	84 b5       	in	r24, 0x24	; 36
 322:	81 60       	ori	r24, 0x01	; 1
 324:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 326:	85 b5       	in	r24, 0x25	; 37
 328:	82 60       	ori	r24, 0x02	; 2
 32a:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 32c:	85 b5       	in	r24, 0x25	; 37
 32e:	81 60       	ori	r24, 0x01	; 1
 330:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 332:	ee e6       	ldi	r30, 0x6E	; 110
 334:	f0 e0       	ldi	r31, 0x00	; 0
 336:	80 81       	ld	r24, Z
 338:	81 60       	ori	r24, 0x01	; 1
 33a:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 33c:	e1 e8       	ldi	r30, 0x81	; 129
 33e:	f0 e0       	ldi	r31, 0x00	; 0
 340:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 342:	80 81       	ld	r24, Z
 344:	82 60       	ori	r24, 0x02	; 2
 346:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 348:	80 81       	ld	r24, Z
 34a:	81 60       	ori	r24, 0x01	; 1
 34c:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 34e:	e0 e8       	ldi	r30, 0x80	; 128
 350:	f0 e0       	ldi	r31, 0x00	; 0
 352:	80 81       	ld	r24, Z
 354:	81 60       	ori	r24, 0x01	; 1
 356:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 358:	e1 eb       	ldi	r30, 0xB1	; 177
 35a:	f0 e0       	ldi	r31, 0x00	; 0
 35c:	80 81       	ld	r24, Z
 35e:	84 60       	ori	r24, 0x04	; 4
 360:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 362:	e0 eb       	ldi	r30, 0xB0	; 176
 364:	f0 e0       	ldi	r31, 0x00	; 0
 366:	80 81       	ld	r24, Z
 368:	81 60       	ori	r24, 0x01	; 1
 36a:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 36c:	ea e7       	ldi	r30, 0x7A	; 122
 36e:	f0 e0       	ldi	r31, 0x00	; 0
 370:	80 81       	ld	r24, Z
 372:	84 60       	ori	r24, 0x04	; 4
 374:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 376:	80 81       	ld	r24, Z
 378:	82 60       	ori	r24, 0x02	; 2
 37a:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 37c:	80 81       	ld	r24, Z
 37e:	81 60       	ori	r24, 0x01	; 1
 380:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 382:	80 81       	ld	r24, Z
 384:	80 68       	ori	r24, 0x80	; 128
 386:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 388:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
#endif
}
 38c:	08 95       	ret

0000038e <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 38e:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 390:	91 8d       	ldd	r25, Z+25	; 0x19
 392:	22 8d       	ldd	r18, Z+26	; 0x1a
 394:	89 2f       	mov	r24, r25
 396:	90 e0       	ldi	r25, 0x00	; 0
 398:	80 5c       	subi	r24, 0xC0	; 192
 39a:	9f 4f       	sbci	r25, 0xFF	; 255
 39c:	82 1b       	sub	r24, r18
 39e:	91 09       	sbc	r25, r1
}
 3a0:	8f 73       	andi	r24, 0x3F	; 63
 3a2:	99 27       	eor	r25, r25
 3a4:	08 95       	ret

000003a6 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
 3a6:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
 3a8:	91 8d       	ldd	r25, Z+25	; 0x19
 3aa:	82 8d       	ldd	r24, Z+26	; 0x1a
 3ac:	98 17       	cp	r25, r24
 3ae:	31 f0       	breq	.+12     	; 0x3bc <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 3b0:	82 8d       	ldd	r24, Z+26	; 0x1a
 3b2:	e8 0f       	add	r30, r24
 3b4:	f1 1d       	adc	r31, r1
 3b6:	85 8d       	ldd	r24, Z+29	; 0x1d
 3b8:	90 e0       	ldi	r25, 0x00	; 0
 3ba:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 3bc:	8f ef       	ldi	r24, 0xFF	; 255
 3be:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 3c0:	08 95       	ret

000003c2 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
 3c2:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 3c4:	91 8d       	ldd	r25, Z+25	; 0x19
 3c6:	82 8d       	ldd	r24, Z+26	; 0x1a
 3c8:	98 17       	cp	r25, r24
 3ca:	61 f0       	breq	.+24     	; 0x3e4 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 3cc:	a2 8d       	ldd	r26, Z+26	; 0x1a
 3ce:	ae 0f       	add	r26, r30
 3d0:	bf 2f       	mov	r27, r31
 3d2:	b1 1d       	adc	r27, r1
 3d4:	5d 96       	adiw	r26, 0x1d	; 29
 3d6:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 3d8:	92 8d       	ldd	r25, Z+26	; 0x1a
 3da:	9f 5f       	subi	r25, 0xFF	; 255
 3dc:	9f 73       	andi	r25, 0x3F	; 63
 3de:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 3e4:	8f ef       	ldi	r24, 0xFF	; 255
 3e6:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 3e8:	08 95       	ret

000003ea <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 3ea:	fc 01       	movw	r30, r24
 3ec:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
 3ee:	44 8d       	ldd	r20, Z+28	; 0x1c
 3f0:	25 2f       	mov	r18, r21
 3f2:	30 e0       	ldi	r19, 0x00	; 0
 3f4:	84 2f       	mov	r24, r20
 3f6:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 3f8:	82 1b       	sub	r24, r18
 3fa:	93 0b       	sbc	r25, r19
 3fc:	54 17       	cp	r21, r20
 3fe:	10 f0       	brcs	.+4      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
 400:	cf 96       	adiw	r24, 0x3f	; 63
 402:	08 95       	ret
  return tail - head - 1;
 404:	01 97       	sbiw	r24, 0x01	; 1
}
 406:	08 95       	ret

00000408 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 408:	8b e5       	ldi	r24, 0x5B	; 91
 40a:	93 e0       	ldi	r25, 0x03	; 3
 40c:	89 2b       	or	r24, r25
 40e:	49 f0       	breq	.+18     	; 0x422 <_Z14serialEventRunv+0x1a>
 410:	80 e0       	ldi	r24, 0x00	; 0
 412:	90 e0       	ldi	r25, 0x00	; 0
 414:	89 2b       	or	r24, r25
 416:	29 f0       	breq	.+10     	; 0x422 <_Z14serialEventRunv+0x1a>
 418:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <_Z17Serial0_availablev>
 41c:	81 11       	cpse	r24, r1
 41e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
 422:	08 95       	ret

00000424 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 424:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 426:	a4 8d       	ldd	r26, Z+28	; 0x1c
 428:	a8 0f       	add	r26, r24
 42a:	b9 2f       	mov	r27, r25
 42c:	b1 1d       	adc	r27, r1
 42e:	a3 5a       	subi	r26, 0xA3	; 163
 430:	bf 4f       	sbci	r27, 0xFF	; 255
 432:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 434:	84 8d       	ldd	r24, Z+28	; 0x1c
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	01 96       	adiw	r24, 0x01	; 1
 43a:	8f 73       	andi	r24, 0x3F	; 63
 43c:	99 27       	eor	r25, r25
 43e:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
 440:	a6 89       	ldd	r26, Z+22	; 0x16
 442:	b7 89       	ldd	r27, Z+23	; 0x17
 444:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 446:	a0 89       	ldd	r26, Z+16	; 0x10
 448:	b1 89       	ldd	r27, Z+17	; 0x11
 44a:	8c 91       	ld	r24, X
 44c:	83 70       	andi	r24, 0x03	; 3
 44e:	80 64       	ori	r24, 0x40	; 64
 450:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 452:	93 8d       	ldd	r25, Z+27	; 0x1b
 454:	84 8d       	ldd	r24, Z+28	; 0x1c
 456:	98 13       	cpse	r25, r24
 458:	06 c0       	rjmp	.+12     	; 0x466 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 45a:	02 88       	ldd	r0, Z+18	; 0x12
 45c:	f3 89       	ldd	r31, Z+19	; 0x13
 45e:	e0 2d       	mov	r30, r0
 460:	80 81       	ld	r24, Z
 462:	8f 7d       	andi	r24, 0xDF	; 223
 464:	80 83       	st	Z, r24
  }
}
 466:	08 95       	ret

00000468 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 468:	cf 93       	push	r28
 46a:	df 93       	push	r29
 46c:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 46e:	88 8d       	ldd	r24, Y+24	; 0x18
 470:	88 23       	and	r24, r24
 472:	b9 f0       	breq	.+46     	; 0x4a2 <_ZN14HardwareSerial5flushEv+0x3a>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 474:	aa 89       	ldd	r26, Y+18	; 0x12
 476:	bb 89       	ldd	r27, Y+19	; 0x13
 478:	e8 89       	ldd	r30, Y+16	; 0x10
 47a:	f9 89       	ldd	r31, Y+17	; 0x11
 47c:	8c 91       	ld	r24, X
 47e:	85 fd       	sbrc	r24, 5
 480:	03 c0       	rjmp	.+6      	; 0x488 <_ZN14HardwareSerial5flushEv+0x20>
 482:	80 81       	ld	r24, Z
 484:	86 fd       	sbrc	r24, 6
 486:	0d c0       	rjmp	.+26     	; 0x4a2 <_ZN14HardwareSerial5flushEv+0x3a>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 488:	0f b6       	in	r0, 0x3f	; 63
 48a:	07 fc       	sbrc	r0, 7
 48c:	f7 cf       	rjmp	.-18     	; 0x47c <_ZN14HardwareSerial5flushEv+0x14>
 48e:	8c 91       	ld	r24, X
 490:	85 ff       	sbrs	r24, 5
 492:	f2 cf       	rjmp	.-28     	; 0x478 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 494:	80 81       	ld	r24, Z
 496:	85 ff       	sbrs	r24, 5
 498:	ed cf       	rjmp	.-38     	; 0x474 <_ZN14HardwareSerial5flushEv+0xc>
	  _tx_udr_empty_irq();
 49a:	ce 01       	movw	r24, r28
 49c:	0e 94 12 02 	call	0x424	; 0x424 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 4a0:	e9 cf       	rjmp	.-46     	; 0x474 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 4a2:	df 91       	pop	r29
 4a4:	cf 91       	pop	r28
 4a6:	08 95       	ret

000004a8 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
 4a8:	ef 92       	push	r14
 4aa:	ff 92       	push	r15
 4ac:	0f 93       	push	r16
 4ae:	1f 93       	push	r17
 4b0:	cf 93       	push	r28
 4b2:	df 93       	push	r29
 4b4:	ec 01       	movw	r28, r24
  _written = true;
 4b6:	81 e0       	ldi	r24, 0x01	; 1
 4b8:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 4ba:	9b 8d       	ldd	r25, Y+27	; 0x1b
 4bc:	8c 8d       	ldd	r24, Y+28	; 0x1c
 4be:	98 13       	cpse	r25, r24
 4c0:	1a c0       	rjmp	.+52     	; 0x4f6 <_ZN14HardwareSerial5writeEh+0x4e>
 4c2:	e8 89       	ldd	r30, Y+16	; 0x10
 4c4:	f9 89       	ldd	r31, Y+17	; 0x11
 4c6:	80 81       	ld	r24, Z
 4c8:	85 ff       	sbrs	r24, 5
 4ca:	15 c0       	rjmp	.+42     	; 0x4f6 <_ZN14HardwareSerial5writeEh+0x4e>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 4cc:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 4ce:	f8 94       	cli
      *_udr = c;
 4d0:	ee 89       	ldd	r30, Y+22	; 0x16
 4d2:	ff 89       	ldd	r31, Y+23	; 0x17
 4d4:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
 4d6:	e8 89       	ldd	r30, Y+16	; 0x10
 4d8:	f9 89       	ldd	r31, Y+17	; 0x11
 4da:	80 81       	ld	r24, Z
 4dc:	83 70       	andi	r24, 0x03	; 3
 4de:	80 64       	ori	r24, 0x40	; 64
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
 4e0:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 4e2:	9f bf       	out	0x3f, r25	; 63
  }
  
  return 1;
}
 4e4:	81 e0       	ldi	r24, 0x01	; 1
 4e6:	90 e0       	ldi	r25, 0x00	; 0
 4e8:	df 91       	pop	r29
 4ea:	cf 91       	pop	r28
 4ec:	1f 91       	pop	r17
 4ee:	0f 91       	pop	r16
 4f0:	ff 90       	pop	r15
 4f2:	ef 90       	pop	r14
 4f4:	08 95       	ret
 4f6:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 4f8:	0b 8d       	ldd	r16, Y+27	; 0x1b
 4fa:	10 e0       	ldi	r17, 0x00	; 0
 4fc:	0f 5f       	subi	r16, 0xFF	; 255
 4fe:	1f 4f       	sbci	r17, 0xFF	; 255
 500:	0f 73       	andi	r16, 0x3F	; 63
 502:	11 27       	eor	r17, r17
 504:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 506:	8c 8d       	ldd	r24, Y+28	; 0x1c
 508:	8e 11       	cpse	r24, r14
 50a:	0c c0       	rjmp	.+24     	; 0x524 <_ZN14HardwareSerial5writeEh+0x7c>
    if (bit_is_clear(SREG, SREG_I)) {
 50c:	0f b6       	in	r0, 0x3f	; 63
 50e:	07 fc       	sbrc	r0, 7
 510:	fa cf       	rjmp	.-12     	; 0x506 <_ZN14HardwareSerial5writeEh+0x5e>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 512:	e8 89       	ldd	r30, Y+16	; 0x10
 514:	f9 89       	ldd	r31, Y+17	; 0x11
 516:	80 81       	ld	r24, Z
 518:	85 ff       	sbrs	r24, 5
 51a:	f5 cf       	rjmp	.-22     	; 0x506 <_ZN14HardwareSerial5writeEh+0x5e>
	_tx_udr_empty_irq();
 51c:	ce 01       	movw	r24, r28
 51e:	0e 94 12 02 	call	0x424	; 0x424 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 522:	f1 cf       	rjmp	.-30     	; 0x506 <_ZN14HardwareSerial5writeEh+0x5e>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 524:	eb 8d       	ldd	r30, Y+27	; 0x1b
 526:	ec 0f       	add	r30, r28
 528:	fd 2f       	mov	r31, r29
 52a:	f1 1d       	adc	r31, r1
 52c:	e3 5a       	subi	r30, 0xA3	; 163
 52e:	ff 4f       	sbci	r31, 0xFF	; 255
 530:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 532:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 534:	f8 94       	cli
    _tx_buffer_head = i;
 536:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
 538:	ea 89       	ldd	r30, Y+18	; 0x12
 53a:	fb 89       	ldd	r31, Y+19	; 0x13
 53c:	80 81       	ld	r24, Z
 53e:	80 62       	ori	r24, 0x20	; 32
 540:	cf cf       	rjmp	.-98     	; 0x4e0 <_ZN14HardwareSerial5writeEh+0x38>

00000542 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
 542:	cf 92       	push	r12
 544:	df 92       	push	r13
 546:	ef 92       	push	r14
 548:	ff 92       	push	r15
 54a:	1f 93       	push	r17
 54c:	cf 93       	push	r28
 54e:	df 93       	push	r29
 550:	ec 01       	movw	r28, r24
 552:	6a 01       	movw	r12, r20
 554:	7b 01       	movw	r14, r22
 556:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 558:	e8 89       	ldd	r30, Y+16	; 0x10
 55a:	f9 89       	ldd	r31, Y+17	; 0x11
 55c:	82 e0       	ldi	r24, 0x02	; 2
 55e:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
 560:	c1 14       	cp	r12, r1
 562:	81 ee       	ldi	r24, 0xE1	; 225
 564:	d8 06       	cpc	r13, r24
 566:	e1 04       	cpc	r14, r1
 568:	f1 04       	cpc	r15, r1
 56a:	a1 f0       	breq	.+40     	; 0x594 <_ZN14HardwareSerial5beginEmh+0x52>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
 56c:	60 e0       	ldi	r22, 0x00	; 0
 56e:	79 e0       	ldi	r23, 0x09	; 9
 570:	8d e3       	ldi	r24, 0x3D	; 61
 572:	90 e0       	ldi	r25, 0x00	; 0
 574:	a7 01       	movw	r20, r14
 576:	96 01       	movw	r18, r12
 578:	0e 94 bb 06 	call	0xd76	; 0xd76 <__udivmodsi4>
 57c:	21 50       	subi	r18, 0x01	; 1
 57e:	31 09       	sbc	r19, r1
 580:	41 09       	sbc	r20, r1
 582:	51 09       	sbc	r21, r1
 584:	56 95       	lsr	r21
 586:	47 95       	ror	r20
 588:	37 95       	ror	r19
 58a:	27 95       	ror	r18
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
 58c:	21 15       	cp	r18, r1
 58e:	80 e1       	ldi	r24, 0x10	; 16
 590:	38 07       	cpc	r19, r24
 592:	98 f0       	brcs	.+38     	; 0x5ba <_ZN14HardwareSerial5beginEmh+0x78>
  {
    *_ucsra = 0;
 594:	e8 89       	ldd	r30, Y+16	; 0x10
 596:	f9 89       	ldd	r31, Y+17	; 0x11
 598:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
 59a:	60 e8       	ldi	r22, 0x80	; 128
 59c:	74 e8       	ldi	r23, 0x84	; 132
 59e:	8e e1       	ldi	r24, 0x1E	; 30
 5a0:	90 e0       	ldi	r25, 0x00	; 0
 5a2:	a7 01       	movw	r20, r14
 5a4:	96 01       	movw	r18, r12
 5a6:	0e 94 bb 06 	call	0xd76	; 0xd76 <__udivmodsi4>
 5aa:	21 50       	subi	r18, 0x01	; 1
 5ac:	31 09       	sbc	r19, r1
 5ae:	41 09       	sbc	r20, r1
 5b0:	51 09       	sbc	r21, r1
 5b2:	56 95       	lsr	r21
 5b4:	47 95       	ror	r20
 5b6:	37 95       	ror	r19
 5b8:	27 95       	ror	r18
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 5ba:	ec 85       	ldd	r30, Y+12	; 0x0c
 5bc:	fd 85       	ldd	r31, Y+13	; 0x0d
 5be:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
 5c0:	ee 85       	ldd	r30, Y+14	; 0x0e
 5c2:	ff 85       	ldd	r31, Y+15	; 0x0f
 5c4:	20 83       	st	Z, r18

  _written = false;
 5c6:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 5c8:	ec 89       	ldd	r30, Y+20	; 0x14
 5ca:	fd 89       	ldd	r31, Y+21	; 0x15
 5cc:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
 5ce:	ea 89       	ldd	r30, Y+18	; 0x12
 5d0:	fb 89       	ldd	r31, Y+19	; 0x13
 5d2:	80 81       	ld	r24, Z
 5d4:	80 61       	ori	r24, 0x10	; 16
 5d6:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
 5d8:	ea 89       	ldd	r30, Y+18	; 0x12
 5da:	fb 89       	ldd	r31, Y+19	; 0x13
 5dc:	80 81       	ld	r24, Z
 5de:	88 60       	ori	r24, 0x08	; 8
 5e0:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
 5e2:	ea 89       	ldd	r30, Y+18	; 0x12
 5e4:	fb 89       	ldd	r31, Y+19	; 0x13
 5e6:	80 81       	ld	r24, Z
 5e8:	80 68       	ori	r24, 0x80	; 128
 5ea:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
 5ec:	ea 89       	ldd	r30, Y+18	; 0x12
 5ee:	fb 89       	ldd	r31, Y+19	; 0x13
 5f0:	80 81       	ld	r24, Z
 5f2:	8f 7d       	andi	r24, 0xDF	; 223
 5f4:	80 83       	st	Z, r24
}
 5f6:	df 91       	pop	r29
 5f8:	cf 91       	pop	r28
 5fa:	1f 91       	pop	r17
 5fc:	ff 90       	pop	r15
 5fe:	ef 90       	pop	r14
 600:	df 90       	pop	r13
 602:	cf 90       	pop	r12
 604:	08 95       	ret

00000606 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 606:	1f 92       	push	r1
 608:	0f 92       	push	r0
 60a:	0f b6       	in	r0, 0x3f	; 63
 60c:	0f 92       	push	r0
 60e:	11 24       	eor	r1, r1
 610:	2f 93       	push	r18
 612:	8f 93       	push	r24
 614:	9f 93       	push	r25
 616:	ef 93       	push	r30
 618:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 61a:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <Serial+0x10>
 61e:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <Serial+0x11>
 622:	80 81       	ld	r24, Z
 624:	e0 91 eb 01 	lds	r30, 0x01EB	; 0x8001eb <Serial+0x16>
 628:	f0 91 ec 01 	lds	r31, 0x01EC	; 0x8001ec <Serial+0x17>
 62c:	82 fd       	sbrc	r24, 2
 62e:	1b c0       	rjmp	.+54     	; 0x666 <__vector_18+0x60>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 630:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 632:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <Serial+0x19>
 636:	8f 5f       	subi	r24, 0xFF	; 255
 638:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 63a:	20 91 ef 01 	lds	r18, 0x01EF	; 0x8001ef <Serial+0x1a>
 63e:	82 17       	cp	r24, r18
 640:	41 f0       	breq	.+16     	; 0x652 <__vector_18+0x4c>
      _rx_buffer[_rx_buffer_head] = c;
 642:	e0 91 ee 01 	lds	r30, 0x01EE	; 0x8001ee <Serial+0x19>
 646:	f0 e0       	ldi	r31, 0x00	; 0
 648:	eb 52       	subi	r30, 0x2B	; 43
 64a:	fe 4f       	sbci	r31, 0xFE	; 254
 64c:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
 64e:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <Serial+0x19>
    Serial._rx_complete_irq();
  }
 652:	ff 91       	pop	r31
 654:	ef 91       	pop	r30
 656:	9f 91       	pop	r25
 658:	8f 91       	pop	r24
 65a:	2f 91       	pop	r18
 65c:	0f 90       	pop	r0
 65e:	0f be       	out	0x3f, r0	; 63
 660:	0f 90       	pop	r0
 662:	1f 90       	pop	r1
 664:	18 95       	reti
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 666:	80 81       	ld	r24, Z
 668:	f4 cf       	rjmp	.-24     	; 0x652 <__vector_18+0x4c>

0000066a <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 66a:	1f 92       	push	r1
 66c:	0f 92       	push	r0
 66e:	0f b6       	in	r0, 0x3f	; 63
 670:	0f 92       	push	r0
 672:	11 24       	eor	r1, r1
 674:	2f 93       	push	r18
 676:	3f 93       	push	r19
 678:	4f 93       	push	r20
 67a:	5f 93       	push	r21
 67c:	6f 93       	push	r22
 67e:	7f 93       	push	r23
 680:	8f 93       	push	r24
 682:	9f 93       	push	r25
 684:	af 93       	push	r26
 686:	bf 93       	push	r27
 688:	ef 93       	push	r30
 68a:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
 68c:	85 ed       	ldi	r24, 0xD5	; 213
 68e:	91 e0       	ldi	r25, 0x01	; 1
 690:	0e 94 12 02 	call	0x424	; 0x424 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
 694:	ff 91       	pop	r31
 696:	ef 91       	pop	r30
 698:	bf 91       	pop	r27
 69a:	af 91       	pop	r26
 69c:	9f 91       	pop	r25
 69e:	8f 91       	pop	r24
 6a0:	7f 91       	pop	r23
 6a2:	6f 91       	pop	r22
 6a4:	5f 91       	pop	r21
 6a6:	4f 91       	pop	r20
 6a8:	3f 91       	pop	r19
 6aa:	2f 91       	pop	r18
 6ac:	0f 90       	pop	r0
 6ae:	0f be       	out	0x3f, r0	; 63
 6b0:	0f 90       	pop	r0
 6b2:	1f 90       	pop	r1
 6b4:	18 95       	reti

000006b6 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 6b6:	85 ed       	ldi	r24, 0xD5	; 213
 6b8:	91 e0       	ldi	r25, 0x01	; 1
 6ba:	0e 94 c7 01 	call	0x38e	; 0x38e <_ZN14HardwareSerial9availableEv>
 6be:	21 e0       	ldi	r18, 0x01	; 1
 6c0:	89 2b       	or	r24, r25
 6c2:	09 f4       	brne	.+2      	; 0x6c6 <_Z17Serial0_availablev+0x10>
 6c4:	20 e0       	ldi	r18, 0x00	; 0
}
 6c6:	82 2f       	mov	r24, r18
 6c8:	08 95       	ret

000006ca <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 6ca:	e5 ed       	ldi	r30, 0xD5	; 213
 6cc:	f1 e0       	ldi	r31, 0x01	; 1
 6ce:	13 82       	std	Z+3, r1	; 0x03
 6d0:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
 6d2:	88 ee       	ldi	r24, 0xE8	; 232
 6d4:	93 e0       	ldi	r25, 0x03	; 3
 6d6:	a0 e0       	ldi	r26, 0x00	; 0
 6d8:	b0 e0       	ldi	r27, 0x00	; 0
 6da:	84 83       	std	Z+4, r24	; 0x04
 6dc:	95 83       	std	Z+5, r25	; 0x05
 6de:	a6 83       	std	Z+6, r26	; 0x06
 6e0:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 6e2:	8a eb       	ldi	r24, 0xBA	; 186
 6e4:	91 e0       	ldi	r25, 0x01	; 1
 6e6:	91 83       	std	Z+1, r25	; 0x01
 6e8:	80 83       	st	Z, r24
 6ea:	85 ec       	ldi	r24, 0xC5	; 197
 6ec:	90 e0       	ldi	r25, 0x00	; 0
 6ee:	95 87       	std	Z+13, r25	; 0x0d
 6f0:	84 87       	std	Z+12, r24	; 0x0c
 6f2:	84 ec       	ldi	r24, 0xC4	; 196
 6f4:	90 e0       	ldi	r25, 0x00	; 0
 6f6:	97 87       	std	Z+15, r25	; 0x0f
 6f8:	86 87       	std	Z+14, r24	; 0x0e
 6fa:	80 ec       	ldi	r24, 0xC0	; 192
 6fc:	90 e0       	ldi	r25, 0x00	; 0
 6fe:	91 8b       	std	Z+17, r25	; 0x11
 700:	80 8b       	std	Z+16, r24	; 0x10
 702:	81 ec       	ldi	r24, 0xC1	; 193
 704:	90 e0       	ldi	r25, 0x00	; 0
 706:	93 8b       	std	Z+19, r25	; 0x13
 708:	82 8b       	std	Z+18, r24	; 0x12
 70a:	82 ec       	ldi	r24, 0xC2	; 194
 70c:	90 e0       	ldi	r25, 0x00	; 0
 70e:	95 8b       	std	Z+21, r25	; 0x15
 710:	84 8b       	std	Z+20, r24	; 0x14
 712:	86 ec       	ldi	r24, 0xC6	; 198
 714:	90 e0       	ldi	r25, 0x00	; 0
 716:	97 8b       	std	Z+23, r25	; 0x17
 718:	86 8b       	std	Z+22, r24	; 0x16
 71a:	11 8e       	std	Z+25, r1	; 0x19
 71c:	12 8e       	std	Z+26, r1	; 0x1a
 71e:	13 8e       	std	Z+27, r1	; 0x1b
 720:	14 8e       	std	Z+28, r1	; 0x1c
 722:	08 95       	ret

00000724 <_ZN5Print5writeEPKhj>:
size_t Print::println(const String &s)
{
  size_t n = print(s);
  n += println();
  return n;
}
 724:	af 92       	push	r10
 726:	bf 92       	push	r11
 728:	cf 92       	push	r12
 72a:	df 92       	push	r13
 72c:	ef 92       	push	r14
 72e:	ff 92       	push	r15
 730:	0f 93       	push	r16
 732:	1f 93       	push	r17
 734:	cf 93       	push	r28
 736:	df 93       	push	r29
 738:	6c 01       	movw	r12, r24
 73a:	7b 01       	movw	r14, r22
 73c:	8b 01       	movw	r16, r22
 73e:	04 0f       	add	r16, r20
 740:	15 1f       	adc	r17, r21
 742:	eb 01       	movw	r28, r22
 744:	5e 01       	movw	r10, r28
 746:	ae 18       	sub	r10, r14
 748:	bf 08       	sbc	r11, r15
 74a:	c0 17       	cp	r28, r16
 74c:	d1 07       	cpc	r29, r17
 74e:	59 f0       	breq	.+22     	; 0x766 <_ZN5Print5writeEPKhj+0x42>
 750:	69 91       	ld	r22, Y+
 752:	d6 01       	movw	r26, r12
 754:	ed 91       	ld	r30, X+
 756:	fc 91       	ld	r31, X
 758:	01 90       	ld	r0, Z+
 75a:	f0 81       	ld	r31, Z
 75c:	e0 2d       	mov	r30, r0
 75e:	c6 01       	movw	r24, r12
 760:	09 95       	icall
 762:	89 2b       	or	r24, r25
 764:	79 f7       	brne	.-34     	; 0x744 <_ZN5Print5writeEPKhj+0x20>
 766:	c5 01       	movw	r24, r10
 768:	df 91       	pop	r29
 76a:	cf 91       	pop	r28
 76c:	1f 91       	pop	r17
 76e:	0f 91       	pop	r16
 770:	ff 90       	pop	r15
 772:	ef 90       	pop	r14
 774:	df 90       	pop	r13
 776:	cf 90       	pop	r12
 778:	bf 90       	pop	r11
 77a:	af 90       	pop	r10
 77c:	08 95       	ret

0000077e <_ZN5Print5writeEPKc.part.2>:
 77e:	fb 01       	movw	r30, r22
 780:	01 90       	ld	r0, Z+
 782:	00 20       	and	r0, r0
 784:	e9 f7       	brne	.-6      	; 0x780 <_ZN5Print5writeEPKc.part.2+0x2>
 786:	31 97       	sbiw	r30, 0x01	; 1
 788:	af 01       	movw	r20, r30
 78a:	46 1b       	sub	r20, r22
 78c:	57 0b       	sbc	r21, r23
 78e:	dc 01       	movw	r26, r24
 790:	ed 91       	ld	r30, X+
 792:	fc 91       	ld	r31, X
 794:	02 80       	ldd	r0, Z+2	; 0x02
 796:	f3 81       	ldd	r31, Z+3	; 0x03
 798:	e0 2d       	mov	r30, r0
 79a:	09 94       	ijmp

0000079c <_ZN5Print7printlnEv>:
 79c:	65 e4       	ldi	r22, 0x45	; 69
 79e:	71 e0       	ldi	r23, 0x01	; 1
 7a0:	0c 94 bf 03 	jmp	0x77e	; 0x77e <_ZN5Print5writeEPKc.part.2>

000007a4 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 7a4:	0f 93       	push	r16
 7a6:	1f 93       	push	r17
 7a8:	cf 93       	push	r28
 7aa:	df 93       	push	r29
 7ac:	8c 01       	movw	r16, r24
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 7ae:	d0 e0       	ldi	r29, 0x00	; 0
 7b0:	c0 e0       	ldi	r28, 0x00	; 0
 7b2:	61 15       	cp	r22, r1
 7b4:	71 05       	cpc	r23, r1
 7b6:	19 f0       	breq	.+6      	; 0x7be <_ZN5Print7printlnEPKc+0x1a>
 7b8:	0e 94 bf 03 	call	0x77e	; 0x77e <_ZN5Print5writeEPKc.part.2>
 7bc:	ec 01       	movw	r28, r24
  size_t n = print(c);
  n += println();
 7be:	c8 01       	movw	r24, r16
 7c0:	0e 94 ce 03 	call	0x79c	; 0x79c <_ZN5Print7printlnEv>
  return n;
}
 7c4:	8c 0f       	add	r24, r28
 7c6:	9d 1f       	adc	r25, r29
 7c8:	df 91       	pop	r29
 7ca:	cf 91       	pop	r28
 7cc:	1f 91       	pop	r17
 7ce:	0f 91       	pop	r16
 7d0:	08 95       	ret

000007d2 <StartOS>:
#endif /* OSEE_HAS_ERRORHOOK */
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
 7d2:	4f 92       	push	r4
 7d4:	5f 92       	push	r5
 7d6:	6f 92       	push	r6
 7d8:	7f 92       	push	r7
 7da:	8f 92       	push	r8
 7dc:	9f 92       	push	r9
 7de:	af 92       	push	r10
 7e0:	bf 92       	push	r11
 7e2:	cf 92       	push	r12
 7e4:	df 92       	push	r13
 7e6:	ef 92       	push	r14
 7e8:	ff 92       	push	r15
 7ea:	0f 93       	push	r16
 7ec:	1f 93       	push	r17
 7ee:	cf 93       	push	r28
 7f0:	df 93       	push	r29
 7f2:	00 d0       	rcall	.+0      	; 0x7f4 <StartOS+0x22>
 7f4:	cd b7       	in	r28, 0x3d	; 61
 7f6:	de b7       	in	r29, 0x3e	; 62
 7f8:	00 91 6b 01 	lds	r16, 0x016B	; 0x80016b <CDB>
 7fc:	10 91 6c 01 	lds	r17, 0x016C	; 0x80016c <CDB+0x1>
 800:	9f b7       	in	r25, 0x3f	; 63
 802:	f8 94       	cli
 804:	d8 01       	movw	r26, r16
 806:	18 96       	adiw	r26, 0x08	; 8
 808:	2d 91       	ld	r18, X+
 80a:	3c 91       	ld	r19, X
 80c:	19 97       	sbiw	r26, 0x09	; 9
 80e:	23 2b       	or	r18, r19
 810:	09 f0       	breq	.+2      	; 0x814 <StartOS+0x42>
 812:	79 c0       	rjmp	.+242    	; 0x906 <__stack+0x7>
 814:	f8 2e       	mov	r15, r24
 816:	8d e6       	ldi	r24, 0x6D	; 109
 818:	96 e0       	ldi	r25, 0x06	; 6
 81a:	9a 83       	std	Y+2, r25	; 0x02
 81c:	89 83       	std	Y+1, r24	; 0x01
 81e:	a0 90 6f 01 	lds	r10, 0x016F	; 0x80016f <CDB+0x4>
 822:	b0 90 70 01 	lds	r11, 0x0170	; 0x800170 <CDB+0x5>
 826:	81 e0       	ldi	r24, 0x01	; 1
 828:	90 e0       	ldi	r25, 0x00	; 0
 82a:	19 96       	adiw	r26, 0x09	; 9
 82c:	9c 93       	st	X, r25
 82e:	8e 93       	st	-X, r24
 830:	18 97       	sbiw	r26, 0x08	; 8
 832:	1a 96       	adiw	r26, 0x0a	; 10
 834:	fc 92       	st	X, r15
 836:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <StartupHook>
 83a:	20 91 71 01 	lds	r18, 0x0171	; 0x800171 <CDB+0x6>
 83e:	30 91 72 01 	lds	r19, 0x0172	; 0x800172 <CDB+0x7>
 842:	38 01       	movw	r6, r16
 844:	b2 e0       	ldi	r27, 0x02	; 2
 846:	6b 0e       	add	r6, r27
 848:	71 1c       	adc	r7, r1
 84a:	d1 2c       	mov	r13, r1
 84c:	c1 2c       	mov	r12, r1
 84e:	e4 e0       	ldi	r30, 0x04	; 4
 850:	fe 9e       	mul	r15, r30
 852:	c0 01       	movw	r24, r0
 854:	11 24       	eor	r1, r1
 856:	79 01       	movw	r14, r18
 858:	e8 0e       	add	r14, r24
 85a:	f9 1e       	adc	r15, r25
 85c:	27 01       	movw	r4, r14
 85e:	f2 e0       	ldi	r31, 0x02	; 2
 860:	4f 0e       	add	r4, r31
 862:	51 1c       	adc	r5, r1
 864:	88 24       	eor	r8, r8
 866:	83 94       	inc	r8
 868:	91 2c       	mov	r9, r1
 86a:	f2 01       	movw	r30, r4
 86c:	80 81       	ld	r24, Z
 86e:	91 81       	ldd	r25, Z+1	; 0x01
 870:	c8 16       	cp	r12, r24
 872:	d9 06       	cpc	r13, r25
 874:	18 f1       	brcs	.+70     	; 0x8bc <StartOS+0xea>
 876:	d8 01       	movw	r26, r16
 878:	18 96       	adiw	r26, 0x08	; 8
 87a:	8d 91       	ld	r24, X+
 87c:	9c 91       	ld	r25, X
 87e:	19 97       	sbiw	r26, 0x09	; 9
 880:	01 97       	sbiw	r24, 0x01	; 1
 882:	31 f4       	brne	.+12     	; 0x890 <StartOS+0xbe>
 884:	82 e0       	ldi	r24, 0x02	; 2
 886:	90 e0       	ldi	r25, 0x00	; 0
 888:	19 96       	adiw	r26, 0x09	; 9
 88a:	9c 93       	st	X, r25
 88c:	8e 93       	st	-X, r24
 88e:	18 97       	sbiw	r26, 0x08	; 8
 890:	f8 01       	movw	r30, r16
 892:	80 85       	ldd	r24, Z+8	; 0x08
 894:	91 85       	ldd	r25, Z+9	; 0x09
 896:	02 97       	sbiw	r24, 0x02	; 2
 898:	41 f4       	brne	.+16     	; 0x8aa <StartOS+0xd8>
 89a:	d5 01       	movw	r26, r10
 89c:	12 96       	adiw	r26, 0x02	; 2
 89e:	6d 91       	ld	r22, X+
 8a0:	7c 91       	ld	r23, X
 8a2:	ab 01       	movw	r20, r22
 8a4:	c5 01       	movw	r24, r10
 8a6:	0e 94 a8 00 	call	0x150	; 0x150 <osEE_hal_save_ctx_and_ready2stacked>
 8aa:	f8 01       	movw	r30, r16
 8ac:	80 85       	ldd	r24, Z+8	; 0x08
 8ae:	91 85       	ldd	r25, Z+9	; 0x09
 8b0:	02 97       	sbiw	r24, 0x02	; 2
 8b2:	09 f4       	brne	.+2      	; 0x8b6 <StartOS+0xe4>
 8b4:	78 94       	sei
 8b6:	90 e0       	ldi	r25, 0x00	; 0
 8b8:	80 e0       	ldi	r24, 0x00	; 0
 8ba:	28 c0       	rjmp	.+80     	; 0x90c <__stack+0xd>
 8bc:	d7 01       	movw	r26, r14
 8be:	ed 91       	ld	r30, X+
 8c0:	fc 91       	ld	r31, X
 8c2:	c6 01       	movw	r24, r12
 8c4:	88 0f       	add	r24, r24
 8c6:	99 1f       	adc	r25, r25
 8c8:	e8 0f       	add	r30, r24
 8ca:	f9 1f       	adc	r31, r25
 8cc:	40 81       	ld	r20, Z
 8ce:	51 81       	ldd	r21, Z+1	; 0x01
 8d0:	da 01       	movw	r26, r20
 8d2:	14 96       	adiw	r26, 0x04	; 4
 8d4:	ed 91       	ld	r30, X+
 8d6:	fc 91       	ld	r31, X
 8d8:	80 81       	ld	r24, Z
 8da:	8f 5f       	subi	r24, 0xFF	; 255
 8dc:	80 83       	st	Z, r24
 8de:	93 82       	std	Z+3, r9	; 0x03
 8e0:	82 82       	std	Z+2, r8	; 0x02
 8e2:	f8 01       	movw	r30, r16
 8e4:	64 81       	ldd	r22, Z+4	; 0x04
 8e6:	75 81       	ldd	r23, Z+5	; 0x05
 8e8:	db 01       	movw	r26, r22
 8ea:	8d 91       	ld	r24, X+
 8ec:	9c 91       	ld	r25, X
 8ee:	11 97       	sbiw	r26, 0x01	; 1
 8f0:	95 83       	std	Z+5, r25	; 0x05
 8f2:	84 83       	std	Z+4, r24	; 0x04
 8f4:	1d 92       	st	X+, r1
 8f6:	1c 92       	st	X, r1
 8f8:	c3 01       	movw	r24, r6
 8fa:	0e 94 a9 05 	call	0xb52	; 0xb52 <osEE_scheduler_rq_insert>
 8fe:	bf ef       	ldi	r27, 0xFF	; 255
 900:	cb 1a       	sub	r12, r27
 902:	db 0a       	sbc	r13, r27
 904:	b2 cf       	rjmp	.-156    	; 0x86a <StartOS+0x98>
 906:	9f bf       	out	0x3f, r25	; 63
 908:	81 e0       	ldi	r24, 0x01	; 1
 90a:	90 e0       	ldi	r25, 0x00	; 0
 90c:	0f 90       	pop	r0
 90e:	0f 90       	pop	r0
 910:	df 91       	pop	r29
 912:	cf 91       	pop	r28
 914:	1f 91       	pop	r17
 916:	0f 91       	pop	r16
 918:	ff 90       	pop	r15
 91a:	ef 90       	pop	r14
 91c:	df 90       	pop	r13
 91e:	cf 90       	pop	r12
 920:	bf 90       	pop	r11
 922:	af 90       	pop	r10
 924:	9f 90       	pop	r9
 926:	8f 90       	pop	r8
 928:	7f 90       	pop	r7
 92a:	6f 90       	pop	r6
 92c:	5f 90       	pop	r5
 92e:	4f 90       	pop	r4
 930:	08 95       	ret

00000932 <TerminateTask>:
  CONSTP2VAR(OsEE_CDB, OS_APPL_DATA, AUTOMATIC)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, OS_APPL_DATA, AUTOMATIC)
    p_ccb       = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_TDB, OS_APPL_DATA, AUTOMATIC)
    p_curr      = p_ccb->p_curr;
 932:	e0 91 6b 01 	lds	r30, 0x016B	; 0x80016b <CDB>
 936:	f0 91 6c 01 	lds	r31, 0x016C	; 0x80016c <CDB+0x1>
 93a:	01 90       	ld	r0, Z+
 93c:	f0 81       	ld	r31, Z
 93e:	e0 2d       	mov	r30, r0
}

/* Suspend/Resume Interrupts */
OSEE_STATIC_INLINE OsEE_reg osEE_hal_suspendIRQ ( void )
{
  register OsEE_reg sr = SREG;
 940:	8f b7       	in	r24, 0x3f	; 63
 =============================================================================*/

/* Disable/Enable Interrupts */
OSEE_STATIC_INLINE void osEE_hal_disableIRQ( void )
{
  cli();
 942:	f8 94       	cli
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
 944:	68 ea       	ldi	r22, 0xA8	; 168
 946:	74 e0       	ldi	r23, 0x04	; 4
 948:	82 81       	ldd	r24, Z+2	; 0x02
 94a:	93 81       	ldd	r25, Z+3	; 0x03
 94c:	0e 94 c8 00 	call	0x190	; 0x190 <osEE_hal_terminate_ctx>

00000950 <osEE_scheduler_task_end>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_end
(
  void
)
{
 950:	cf 93       	push	r28
 952:	df 93       	push	r29
 954:	00 d0       	rcall	.+0      	; 0x956 <osEE_scheduler_task_end+0x6>
 956:	cd b7       	in	r28, 0x3d	; 61
 958:	de b7       	in	r29, 0x3e	; 62
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

  p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), osEE_get_curr_core(),
 95a:	ae 01       	movw	r20, r28
 95c:	4f 5f       	subi	r20, 0xFF	; 255
 95e:	5f 4f       	sbci	r21, 0xFF	; 255
 960:	6b e6       	ldi	r22, 0x6B	; 107
 962:	71 e0       	ldi	r23, 0x01	; 1
 964:	8d e5       	ldi	r24, 0x5D	; 93
 966:	91 e0       	ldi	r25, 0x01	; 1
 968:	0e 94 da 05 	call	0xbb4	; 0xbb4 <osEE_scheduler_task_terminated>
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  osEE_change_context_from_task_end(p_from, p_to);
 96c:	bc 01       	movw	r22, r24
 96e:	89 81       	ldd	r24, Y+1	; 0x01
 970:	9a 81       	ldd	r25, Y+2	; 0x02
 972:	0e 94 8a 06 	call	0xd14	; 0xd14 <osEE_change_context_from_task_end>
  if (p_from->task_type != OSEE_TASK_TYPE_ISR2) {
    osEE_change_context_from_task_end(p_from, p_to);
  } else {
    osEE_change_context_from_isr2_end(p_from, p_to);
  }
}
 976:	0f 90       	pop	r0
 978:	0f 90       	pop	r0
 97a:	df 91       	pop	r29
 97c:	cf 91       	pop	r28
 97e:	08 95       	ret

00000980 <osEE_scheduler_task_wrapper_restore>:
    p_ccb->p_lock_to_be_released = NULL;
  }
#endif /* OSEE_SCHEDULER_GLOBAL */

  return;
}
 980:	08 95       	ret

00000982 <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
 982:	ec 01       	movw	r28, r24
  CONST(TaskPrio, AUTOMATIC) task_prio = p_tdb_to->p_tcb->current_prio;
 984:	ec 81       	ldd	r30, Y+4	; 0x04
 986:	fd 81       	ldd	r31, Y+5	; 0x05
  osEE_scheduler_task_wrapper_restore(p_tdb_to);

  if (task_prio < OSEE_ISR_ALL_PRIO) {
 988:	81 81       	ldd	r24, Z+1	; 0x01
 98a:	8f 3f       	cpi	r24, 0xFF	; 255
 98c:	09 f0       	breq	.+2      	; 0x990 <osEE_scheduler_task_wrapper_run+0xe>
  cli();
}

OSEE_STATIC_INLINE void osEE_hal_enableIRQ( void )
{
  sei();
 98e:	78 94       	sei
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_prio);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
 990:	e9 85       	ldd	r30, Y+9	; 0x09
 992:	fa 85       	ldd	r31, Y+10	; 0x0a
 994:	09 95       	icall
}

/* Suspend/Resume Interrupts */
OSEE_STATIC_INLINE OsEE_reg osEE_hal_suspendIRQ ( void )
{
  register OsEE_reg sr = SREG;
 996:	8f b7       	in	r24, 0x3f	; 63
 =============================================================================*/

/* Disable/Enable Interrupts */
OSEE_STATIC_INLINE void osEE_hal_disableIRQ( void )
{
  cli();
 998:	f8 94       	cli
 99a:	68 ea       	ldi	r22, 0xA8	; 168
 99c:	74 e0       	ldi	r23, 0x04	; 4
 99e:	8a 81       	ldd	r24, Y+2	; 0x02
 9a0:	9b 81       	ldd	r25, Y+3	; 0x03
 9a2:	0e 94 c8 00 	call	0x190	; 0x190 <osEE_hal_terminate_ctx>

000009a6 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
 9a6:	0f 93       	push	r16
 9a8:	1f 93       	push	r17
 9aa:	cf 93       	push	r28
 9ac:	df 93       	push	r29
}

/* Suspend/Resume Interrupts */
OSEE_STATIC_INLINE OsEE_reg osEE_hal_suspendIRQ ( void )
{
  register OsEE_reg sr = SREG;
 9ae:	cf b7       	in	r28, 0x3f	; 63
 =============================================================================*/

/* Disable/Enable Interrupts */
OSEE_STATIC_INLINE void osEE_hal_disableIRQ( void )
{
  cli();
 9b0:	f8 94       	cli
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_get_curr_core();
#if (defined(OSEE_HAS_AUTOSTART_TASK))
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel(), p_cdb);
 9b2:	6b e6       	ldi	r22, 0x6B	; 107
 9b4:	71 e0       	ldi	r23, 0x01	; 1
 9b6:	8d e5       	ldi	r24, 0x5D	; 93
 9b8:	91 e0       	ldi	r25, 0x01	; 1
 9ba:	0e 94 52 06 	call	0xca4	; 0xca4 <osEE_scheduler_task_preemption_point>
}

OSEE_STATIC_INLINE void osEE_hal_resumeIRQ ( OsEE_reg flags )
{
  OSEE_BARRIER();
  SREG = flags;
 9be:	cf bf       	out	0x3f, r28	; 63
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
 9c0:	00 91 6b 01 	lds	r16, 0x016B	; 0x80016b <CDB>
 9c4:	10 91 6c 01 	lds	r17, 0x016C	; 0x80016c <CDB+0x1>
#if (defined(OSEE_HAS_IDLEHOOK)) || (defined(OSEE_API_DYNAMIC))
    CONST(TaskFunc, AUTOMATIC) p_idle_hook = p_cdb->p_idle_hook;
 9c8:	c0 91 6d 01 	lds	r28, 0x016D	; 0x80016d <CDB+0x2>
 9cc:	d0 91 6e 01 	lds	r29, 0x016E	; 0x80016e <CDB+0x3>
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel(), p_cdb);
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
 9d0:	f8 01       	movw	r30, r16
 9d2:	80 85       	ldd	r24, Z+8	; 0x08
 9d4:	91 85       	ldd	r25, Z+9	; 0x09
 9d6:	82 30       	cpi	r24, 0x02	; 2
 9d8:	91 05       	cpc	r25, r1
 9da:	51 f0       	breq	.+20     	; 0x9f0 <osEE_idle_hook_wrapper+0x4a>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
 9dc:	80 91 6f 01 	lds	r24, 0x016F	; 0x80016f <CDB+0x4>
 9e0:	90 91 70 01 	lds	r25, 0x0170	; 0x800170 <CDB+0x5>
}
 9e4:	df 91       	pop	r29
 9e6:	cf 91       	pop	r28
 9e8:	1f 91       	pop	r17
 9ea:	0f 91       	pop	r16
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
 9ec:	0c 94 a0 06 	jmp	0xd40	; 0xd40 <osEE_idle_task_terminate>
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
#if (defined(OSEE_HAS_IDLEHOOK)) || (defined(OSEE_API_DYNAMIC))
    CONST(TaskFunc, AUTOMATIC) p_idle_hook = p_cdb->p_idle_hook;
    if (p_idle_hook != NULL) {
 9f0:	20 97       	sbiw	r28, 0x00	; 0
 9f2:	89 f3       	breq	.-30     	; 0x9d6 <osEE_idle_hook_wrapper+0x30>
      p_idle_hook();
 9f4:	fe 01       	movw	r30, r28
 9f6:	09 95       	icall
 9f8:	eb cf       	rjmp	.-42     	; 0x9d0 <osEE_idle_hook_wrapper+0x2a>

000009fa <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
 9fa:	0f 93       	push	r16
 9fc:	1f 93       	push	r17
 9fe:	cf 93       	push	r28
 a00:	df 93       	push	r29
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
 a02:	ec 01       	movw	r28, r24
 a04:	a8 81       	ld	r26, Y
 a06:	b9 81       	ldd	r27, Y+1	; 0x01
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
 a08:	eb 01       	movw	r28, r22
 a0a:	e8 81       	ld	r30, Y
 a0c:	f9 81       	ldd	r31, Y+1	; 0x01
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_ret_sn = p_ccb->p_stk_sn;
 a0e:	16 96       	adiw	r26, 0x06	; 6
 a10:	cd 91       	ld	r28, X+
 a12:	dc 91       	ld	r29, X
 a14:	17 97       	sbiw	r26, 0x07	; 7

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
 a16:	20 97       	sbiw	r28, 0x00	; 0
 a18:	c1 f1       	breq	.+112    	; 0xa8a <osEE_scheduler_core_rq_preempt_stk+0x90>
    p_ret_tdb = p_ret_sn->p_tdb;
 a1a:	8a 81       	ldd	r24, Y+2	; 0x02
 a1c:	9b 81       	ldd	r25, Y+3	; 0x03
    if (p_rq_sn != NULL) {
 a1e:	30 97       	sbiw	r30, 0x00	; 0
 a20:	09 f4       	brne	.+2      	; 0xa24 <osEE_scheduler_core_rq_preempt_stk+0x2a>
 a22:	3f c0       	rjmp	.+126    	; 0xaa2 <osEE_scheduler_core_rq_preempt_stk+0xa8>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
 a24:	ec 01       	movw	r28, r24
 a26:	0c 81       	ldd	r16, Y+4	; 0x04
 a28:	1d 81       	ldd	r17, Y+5	; 0x05
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
 a2a:	22 81       	ldd	r18, Z+2	; 0x02
 a2c:	33 81       	ldd	r19, Z+3	; 0x03
 a2e:	e9 01       	movw	r28, r18
 a30:	4c 81       	ldd	r20, Y+4	; 0x04
 a32:	5d 81       	ldd	r21, Y+5	; 0x05
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
 a34:	e8 01       	movw	r28, r16
 a36:	39 81       	ldd	r19, Y+1	; 0x01
 a38:	ea 01       	movw	r28, r20
 a3a:	29 81       	ldd	r18, Y+1	; 0x01
 a3c:	32 17       	cp	r19, r18
 a3e:	88 f5       	brcc	.+98     	; 0xaa2 <osEE_scheduler_core_rq_preempt_stk+0xa8>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
 a40:	22 e0       	ldi	r18, 0x02	; 2
 a42:	30 e0       	ldi	r19, 0x00	; 0
 a44:	e8 01       	movw	r28, r16
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    /* Call PostTaskHook before switching active TASK */
    osEE_call_post_task_hook(p_ccb);
    p_ret_tdb                 = p_cdb->p_idle_task;
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
 a46:	3b 83       	std	Y+3, r19	; 0x03
 a48:	2a 83       	std	Y+2, r18	; 0x02
    is_rq_preemption          = OSEE_TRUE;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
 a4a:	20 81       	ld	r18, Z
 a4c:	31 81       	ldd	r19, Z+1	; 0x01
 a4e:	eb 01       	movw	r28, r22
 a50:	39 83       	std	Y+1, r19	; 0x01
 a52:	28 83       	st	Y, r18
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
 a54:	c2 81       	ldd	r28, Z+2	; 0x02
 a56:	d3 81       	ldd	r29, Z+3	; 0x03
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
 a58:	2c 81       	ldd	r18, Y+4	; 0x04
 a5a:	3d 81       	ldd	r19, Y+5	; 0x05
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
 a5c:	16 96       	adiw	r26, 0x06	; 6
 a5e:	4d 91       	ld	r20, X+
 a60:	5c 91       	ld	r21, X
 a62:	17 97       	sbiw	r26, 0x07	; 7
 a64:	51 83       	std	Z+1, r21	; 0x01
 a66:	40 83       	st	Z, r20
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
 a68:	17 96       	adiw	r26, 0x07	; 7
 a6a:	fc 93       	st	X, r31
 a6c:	ee 93       	st	-X, r30
 a6e:	16 97       	sbiw	r26, 0x06	; 6
  p_ccb->p_curr                 = p_tdb;
 a70:	cd 93       	st	X+, r28
 a72:	dc 93       	st	X, r29

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
 a74:	4c 85       	ldd	r20, Y+12	; 0x0c
    if (p_tcb->current_prio < dispatch_prio) {
 a76:	f9 01       	movw	r30, r18
 a78:	51 81       	ldd	r21, Z+1	; 0x01
 a7a:	54 17       	cp	r21, r20
 a7c:	08 f4       	brcc	.+2      	; 0xa80 <osEE_scheduler_core_rq_preempt_stk+0x86>
      p_tcb->current_prio = dispatch_prio;
 a7e:	41 83       	std	Z+1, r20	; 0x01
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
 a80:	df 91       	pop	r29
 a82:	cf 91       	pop	r28
 a84:	1f 91       	pop	r17
 a86:	0f 91       	pop	r16
 a88:	08 95       	ret

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
 a8a:	30 97       	sbiw	r30, 0x00	; 0
 a8c:	51 f0       	breq	.+20     	; 0xaa2 <osEE_scheduler_core_rq_preempt_stk+0xa8>
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    /* Call PostTaskHook before switching active TASK */
    osEE_call_post_task_hook(p_ccb);
    p_ret_tdb                 = p_cdb->p_idle_task;
 a8e:	ec 01       	movw	r28, r24
 a90:	8c 81       	ldd	r24, Y+4	; 0x04
 a92:	9d 81       	ldd	r25, Y+5	; 0x05
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
 a94:	ec 01       	movw	r28, r24
 a96:	4c 81       	ldd	r20, Y+4	; 0x04
 a98:	5d 81       	ldd	r21, Y+5	; 0x05
 a9a:	22 e0       	ldi	r18, 0x02	; 2
 a9c:	30 e0       	ldi	r19, 0x00	; 0
 a9e:	ea 01       	movw	r28, r20
 aa0:	d2 cf       	rjmp	.-92     	; 0xa46 <osEE_scheduler_core_rq_preempt_stk+0x4c>
    (*p_rq)       = p_rq_sn->p_next;

    /* Set as current on top of STK */
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
    p_ret_tdb = NULL;
 aa2:	90 e0       	ldi	r25, 0x00	; 0
 aa4:	80 e0       	ldi	r24, 0x00	; 0
    p_ret_sn  = NULL;
  }
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
 aa6:	ec cf       	rjmp	.-40     	; 0xa80 <osEE_scheduler_core_rq_preempt_stk+0x86>

00000aa8 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   hnd_act
)
{
 aa8:	cf 92       	push	r12
 aaa:	df 92       	push	r13
 aac:	ef 92       	push	r14
 aae:	ff 92       	push	r15
 ab0:	0f 93       	push	r16
 ab2:	1f 93       	push	r17
 ab4:	cf 93       	push	r28
 ab6:	df 93       	push	r29
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new = p_sn_new->p_tdb;
 ab8:	eb 01       	movw	r28, r22
 aba:	aa 81       	ldd	r26, Y+2	; 0x02
 abc:	bb 81       	ldd	r27, Y+3	; 0x03
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
 abe:	14 96       	adiw	r26, 0x04	; 4
 ac0:	ed 91       	ld	r30, X+
 ac2:	fc 91       	ld	r31, X
 ac4:	15 97       	sbiw	r26, 0x05	; 5
  CONST(TaskPrio, AUTOMATIC)                new_task_prio =
 ac6:	41 15       	cp	r20, r1
 ac8:	51 05       	cpc	r21, r1
 aca:	01 f1       	breq	.+64     	; 0xb0c <osEE_sn_priority_insert+0x64>
    ((hnd_act) && osEE_is_active_task(p_tcb_new))?
 acc:	22 81       	ldd	r18, Z+2	; 0x02
 ace:	33 81       	ldd	r19, Z+3	; 0x03
 ad0:	22 30       	cpi	r18, 0x02	; 2
 ad2:	31 05       	cpc	r19, r1
 ad4:	d8 f0       	brcs	.+54     	; 0xb0c <osEE_sn_priority_insert+0x64>
  CONST(OsEE_bool, AUTOMATIC)                   hnd_act
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new = p_sn_new->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
  CONST(TaskPrio, AUTOMATIC)                new_task_prio =
 ad6:	1b 96       	adiw	r26, 0x0b	; 11
 ad8:	2c 91       	ld	r18, X
    ((hnd_act) && osEE_is_active_task(p_tcb_new))?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
 ada:	dc 01       	movw	r26, r24
 adc:	ed 91       	ld	r30, X+
 ade:	fc 91       	ld	r31, X
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
  CONST(TaskPrio, AUTOMATIC)                new_task_prio =
    ((hnd_act) && osEE_is_active_task(p_tcb_new))?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
 ae0:	b0 e0       	ldi	r27, 0x00	; 0
 ae2:	a0 e0       	ldi	r26, 0x00	; 0
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
 ae4:	30 97       	sbiw	r30, 0x00	; 0
 ae6:	a1 f4       	brne	.+40     	; 0xb10 <osEE_sn_priority_insert+0x68>
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
 ae8:	10 97       	sbiw	r26, 0x00	; 0
 aea:	69 f1       	breq	.+90     	; 0xb46 <osEE_sn_priority_insert+0x9e>
    p_prev->p_next = p_sn_new;
 aec:	6d 93       	st	X+, r22
 aee:	7c 93       	st	X, r23
    ((hnd_act) && osEE_is_active_task(p_tcb_new))?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
 af0:	90 e0       	ldi	r25, 0x00	; 0
 af2:	80 e0       	ldi	r24, 0x00	; 0
  } else {
    (*pp_first)   = p_sn_new;
    head_changed  = OSEE_TRUE;
  }

  p_sn_new->p_next = p_curr;
 af4:	eb 01       	movw	r28, r22
 af6:	f9 83       	std	Y+1, r31	; 0x01
 af8:	e8 83       	st	Y, r30

  return head_changed;
}
 afa:	df 91       	pop	r29
 afc:	cf 91       	pop	r28
 afe:	1f 91       	pop	r17
 b00:	0f 91       	pop	r16
 b02:	ff 90       	pop	r15
 b04:	ef 90       	pop	r14
 b06:	df 90       	pop	r13
 b08:	cf 90       	pop	r12
 b0a:	08 95       	ret
  CONST(OsEE_bool, AUTOMATIC)                   hnd_act
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new = p_sn_new->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
  CONST(TaskPrio, AUTOMATIC)                new_task_prio =
 b0c:	21 81       	ldd	r18, Z+1	; 0x01
 b0e:	e5 cf       	rjmp	.-54     	; 0xada <osEE_sn_priority_insert+0x32>
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
 b10:	02 81       	ldd	r16, Z+2	; 0x02
 b12:	13 81       	ldd	r17, Z+3	; 0x03
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
 b14:	e8 01       	movw	r28, r16
 b16:	cc 80       	ldd	r12, Y+4	; 0x04
 b18:	dd 80       	ldd	r13, Y+5	; 0x05

    if (hnd_act && osEE_is_active_task(p_cur_tcb)) {
 b1a:	41 15       	cp	r20, r1
 b1c:	51 05       	cpc	r21, r1
 b1e:	81 f0       	breq	.+32     	; 0xb40 <osEE_sn_priority_insert+0x98>
 b20:	e6 01       	movw	r28, r12
 b22:	ea 80       	ldd	r14, Y+2	; 0x02
 b24:	fb 80       	ldd	r15, Y+3	; 0x03
 b26:	d2 e0       	ldi	r29, 0x02	; 2
 b28:	ed 16       	cp	r14, r29
 b2a:	f1 04       	cpc	r15, r1
 b2c:	48 f0       	brcs	.+18     	; 0xb40 <osEE_sn_priority_insert+0x98>
      prio_to_check = p_cur_tdb->ready_prio;
 b2e:	e8 01       	movw	r28, r16
 b30:	3b 85       	ldd	r19, Y+11	; 0x0b
    } else {
      prio_to_check = p_cur_tcb->current_prio;
    }

    if (new_task_prio <= prio_to_check)
 b32:	32 17       	cp	r19, r18
 b34:	c8 f2       	brcs	.-78     	; 0xae8 <osEE_sn_priority_insert+0x40>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
 b36:	df 01       	movw	r26, r30
 b38:	01 90       	ld	r0, Z+
 b3a:	f0 81       	ld	r31, Z
 b3c:	e0 2d       	mov	r30, r0
 b3e:	d2 cf       	rjmp	.-92     	; 0xae4 <osEE_sn_priority_insert+0x3c>
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (hnd_act && osEE_is_active_task(p_cur_tcb)) {
      prio_to_check = p_cur_tdb->ready_prio;
    } else {
      prio_to_check = p_cur_tcb->current_prio;
 b40:	e6 01       	movw	r28, r12
 b42:	39 81       	ldd	r19, Y+1	; 0x01
 b44:	f6 cf       	rjmp	.-20     	; 0xb32 <osEE_sn_priority_insert+0x8a>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
 b46:	dc 01       	movw	r26, r24
 b48:	6d 93       	st	X+, r22
 b4a:	7c 93       	st	X, r23
    head_changed  = OSEE_TRUE;
 b4c:	81 e0       	ldi	r24, 0x01	; 1
 b4e:	90 e0       	ldi	r25, 0x00	; 0
 b50:	d1 cf       	rjmp	.-94     	; 0xaf4 <osEE_sn_priority_insert+0x4c>

00000b52 <osEE_scheduler_rq_insert>:
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
  p_sn_new->p_tdb = p_tdb_new;
 b52:	fb 01       	movw	r30, r22
 b54:	53 83       	std	Z+3, r21	; 0x03
 b56:	42 83       	std	Z+2, r20	; 0x02

#if (!defined(OSEE_SCHEDULER_GLOBAL))
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
 b58:	41 e0       	ldi	r20, 0x01	; 1
 b5a:	50 e0       	ldi	r21, 0x00	; 0
 b5c:	0c 94 54 05 	jmp	0xaa8	; 0xaa8 <osEE_sn_priority_insert>

00000b60 <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
 b60:	ef 92       	push	r14
 b62:	ff 92       	push	r15
 b64:	0f 93       	push	r16
 b66:	1f 93       	push	r17
 b68:	cf 93       	push	r28
 b6a:	df 93       	push	r29
 b6c:	8c 01       	movw	r16, r24
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
 b6e:	fc 01       	movw	r30, r24
 b70:	c0 81       	ld	r28, Z
 b72:	d1 81       	ldd	r29, Z+1	; 0x01
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
 b74:	ee 80       	ldd	r14, Y+6	; 0x06
 b76:	ff 80       	ldd	r15, Y+7	; 0x07
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
 b78:	f7 01       	movw	r30, r14
 b7a:	80 81       	ld	r24, Z
 b7c:	91 81       	ldd	r25, Z+1	; 0x01
 b7e:	9f 83       	std	Y+7, r25	; 0x07
 b80:	8e 83       	std	Y+6, r24	; 0x06
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
 b82:	c8 01       	movw	r24, r16
 b84:	0e 94 fd 04 	call	0x9fa	; 0x9fa <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
 b88:	89 2b       	or	r24, r25
 b8a:	41 f4       	brne	.+16     	; 0xb9c <osEE_scheduler_core_pop_running+0x3c>
  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
    CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
 b8c:	ee 81       	ldd	r30, Y+6	; 0x06
 b8e:	ff 81       	ldd	r31, Y+7	; 0x07
      if (p_ccb->p_curr->task_type <= OSEE_TASK_TYPE_EXTENDED) {
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if ( p_curr_stk_sn != NULL ) {
 b90:	30 97       	sbiw	r30, 0x00	; 0
 b92:	61 f0       	breq	.+24     	; 0xbac <osEE_scheduler_core_pop_running+0x4c>
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
 b94:	82 81       	ldd	r24, Z+2	; 0x02
 b96:	93 81       	ldd	r25, Z+3	; 0x03
      } else {
        /* Resume IDLE TASK */
        p_tdb_stk = p_cdb->p_idle_task;
      }

      p_ccb->p_curr            = p_tdb_stk;
 b98:	99 83       	std	Y+1, r25	; 0x01
 b9a:	88 83       	st	Y, r24
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
 b9c:	c7 01       	movw	r24, r14
 b9e:	df 91       	pop	r29
 ba0:	cf 91       	pop	r28
 ba2:	1f 91       	pop	r17
 ba4:	0f 91       	pop	r16
 ba6:	ff 90       	pop	r15
 ba8:	ef 90       	pop	r14
 baa:	08 95       	ret
      if ( p_curr_stk_sn != NULL ) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
      } else {
        /* Resume IDLE TASK */
        p_tdb_stk = p_cdb->p_idle_task;
 bac:	f8 01       	movw	r30, r16
 bae:	84 81       	ldd	r24, Z+4	; 0x04
 bb0:	95 81       	ldd	r25, Z+5	; 0x05
 bb2:	f2 cf       	rjmp	.-28     	; 0xb98 <osEE_scheduler_core_pop_running+0x38>

00000bb4 <osEE_scheduler_task_terminated>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)    p_cdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
 bb4:	af 92       	push	r10
 bb6:	bf 92       	push	r11
 bb8:	cf 92       	push	r12
 bba:	df 92       	push	r13
 bbc:	ef 92       	push	r14
 bbe:	ff 92       	push	r15
 bc0:	0f 93       	push	r16
 bc2:	1f 93       	push	r17
 bc4:	cf 93       	push	r28
 bc6:	df 93       	push	r29
 bc8:	5b 01       	movw	r10, r22
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
 bca:	db 01       	movw	r26, r22
 bcc:	cd 91       	ld	r28, X+
 bce:	dc 91       	ld	r29, X
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
 bd0:	fe 01       	movw	r30, r28
 bd2:	01 91       	ld	r16, Z+
 bd4:	11 91       	ld	r17, Z+
 bd6:	7f 01       	movw	r14, r30
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
 bd8:	d8 01       	movw	r26, r16
 bda:	14 96       	adiw	r26, 0x04	; 4
 bdc:	cd 90       	ld	r12, X+
 bde:	dc 90       	ld	r13, X

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
 be0:	fa 01       	movw	r30, r20
 be2:	11 83       	std	Z+1, r17	; 0x01
 be4:	00 83       	st	Z, r16

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
 be6:	d6 01       	movw	r26, r12
 be8:	12 96       	adiw	r26, 0x02	; 2
 bea:	8d 91       	ld	r24, X+
 bec:	9c 91       	ld	r25, X
 bee:	04 97       	sbiw	r24, 0x04	; 4
 bf0:	a9 f5       	brne	.+106    	; 0xc5c <osEE_scheduler_task_terminated+0xa8>
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
 bf2:	b7 01       	movw	r22, r14
 bf4:	c5 01       	movw	r24, r10
 bf6:	0e 94 b0 05 	call	0xb60	; 0xb60 <osEE_scheduler_core_pop_running>
 bfa:	ac 01       	movw	r20, r24

      p_tdb_to = p_ccb->p_curr;
 bfc:	88 81       	ld	r24, Y
 bfe:	99 81       	ldd	r25, Y+1	; 0x01

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
 c00:	08 17       	cp	r16, r24
 c02:	19 07       	cpc	r17, r25
 c04:	31 f1       	breq	.+76     	; 0xc52 <osEE_scheduler_task_terminated+0x9e>
  osEE_task_end
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
 c06:	d8 01       	movw	r26, r16
 c08:	14 96       	adiw	r26, 0x04	; 4
 c0a:	ed 91       	ld	r30, X+
 c0c:	fc 91       	ld	r31, X
 c0e:	15 97       	sbiw	r26, 0x05	; 5

  p_tcb->current_prio = p_tdb->ready_prio;
 c10:	1b 96       	adiw	r26, 0x0b	; 11
 c12:	2c 91       	ld	r18, X
 c14:	21 83       	std	Z+1, r18	; 0x01

  --p_tcb->current_num_of_act;
 c16:	20 81       	ld	r18, Z
 c18:	21 50       	subi	r18, 0x01	; 1
 c1a:	20 83       	st	Z, r18

  if (p_tcb->current_num_of_act == 0U) {
 c1c:	21 11       	cpse	r18, r1
 c1e:	14 c0       	rjmp	.+40     	; 0xc48 <osEE_scheduler_task_terminated+0x94>
    p_tcb->status = OSEE_TASK_SUSPENDED;
 c20:	13 82       	std	Z+3, r1	; 0x03
 c22:	12 82       	std	Z+2, r1	; 0x02
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
 c24:	2c 81       	ldd	r18, Y+4	; 0x04
 c26:	3d 81       	ldd	r19, Y+5	; 0x05
 c28:	da 01       	movw	r26, r20
 c2a:	2d 93       	st	X+, r18
 c2c:	3c 93       	st	X, r19
  (*pp_first)       = p_to_free;
 c2e:	5d 83       	std	Y+5, r21	; 0x05
 c30:	4c 83       	std	Y+4, r20	; 0x04
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
 c32:	df 91       	pop	r29
 c34:	cf 91       	pop	r28
 c36:	1f 91       	pop	r17
 c38:	0f 91       	pop	r16
 c3a:	ff 90       	pop	r15
 c3c:	ef 90       	pop	r14
 c3e:	df 90       	pop	r13
 c40:	cf 90       	pop	r12
 c42:	bf 90       	pop	r11
 c44:	af 90       	pop	r10
 c46:	08 95       	ret
  } else {
    p_tcb->status = OSEE_TASK_READY;
 c48:	21 e0       	ldi	r18, 0x01	; 1
 c4a:	30 e0       	ldi	r19, 0x00	; 0
 c4c:	33 83       	std	Z+3, r19	; 0x03
 c4e:	22 83       	std	Z+2, r18	; 0x02
 c50:	e9 cf       	rjmp	.-46     	; 0xc24 <osEE_scheduler_task_terminated+0x70>
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
 c52:	f6 01       	movw	r30, r12
 c54:	20 81       	ld	r18, Z
 c56:	21 50       	subi	r18, 0x01	; 1
 c58:	20 83       	st	Z, r18
 c5a:	e4 cf       	rjmp	.-56     	; 0xc24 <osEE_scheduler_task_terminated+0x70>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
 c5c:	6e 81       	ldd	r22, Y+6	; 0x06
 c5e:	7f 81       	ldd	r23, Y+7	; 0x07

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
 c60:	fb 01       	movw	r30, r22
 c62:	80 81       	ld	r24, Z
 c64:	91 81       	ldd	r25, Z+1	; 0x01
 c66:	9f 83       	std	Y+7, r25	; 0x07
 c68:	8e 83       	std	Y+6, r24	; 0x06
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
 c6a:	d8 01       	movw	r26, r16
 c6c:	1b 96       	adiw	r26, 0x0b	; 11
 c6e:	8c 91       	ld	r24, X
 c70:	f6 01       	movw	r30, r12
 c72:	81 83       	std	Z+1, r24	; 0x01
      p_tcb_term->status = OSEE_TASK_READY;
 c74:	81 e0       	ldi	r24, 0x01	; 1
 c76:	90 e0       	ldi	r25, 0x00	; 0
 c78:	93 83       	std	Z+3, r25	; 0x03
 c7a:	82 83       	std	Z+2, r24	; 0x02
      if (p_tcb_term->current_num_of_act == 1U) {
        osEE_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
 c7c:	a8 01       	movw	r20, r16
 c7e:	c7 01       	movw	r24, r14
 c80:	0e 94 a9 05 	call	0xb52	; 0xb52 <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
 c84:	b7 01       	movw	r22, r14
 c86:	c5 01       	movw	r24, r10
 c88:	0e 94 fd 04 	call	0x9fa	; 0x9fa <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
 c8c:	89 2b       	or	r24, r25
 c8e:	39 f4       	brne	.+14     	; 0xc9e <osEE_scheduler_task_terminated+0xea>
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
 c90:	ee 81       	ldd	r30, Y+6	; 0x06
 c92:	ff 81       	ldd	r31, Y+7	; 0x07
 c94:	82 81       	ldd	r24, Z+2	; 0x02
 c96:	93 81       	ldd	r25, Z+3	; 0x03
          p_ccb->p_curr           = p_tdb_to;
 c98:	99 83       	std	Y+1, r25	; 0x01
 c9a:	88 83       	st	Y, r24
 c9c:	ca cf       	rjmp	.-108    	; 0xc32 <osEE_scheduler_task_terminated+0x7e>
        } else {
          p_tdb_to = p_ccb->p_curr;
 c9e:	88 81       	ld	r24, Y
 ca0:	99 81       	ldd	r25, Y+1	; 0x01
      /* Chained Termination => SN reused - NO Release */
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
 ca2:	c7 cf       	rjmp	.-114    	; 0xc32 <osEE_scheduler_task_terminated+0x7e>

00000ca4 <osEE_scheduler_task_preemption_point>:
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb
)
{
 ca4:	cf 93       	push	r28
 ca6:	df 93       	push	r29
 ca8:	cb 01       	movw	r24, r22
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
 caa:	fb 01       	movw	r30, r22
 cac:	c0 81       	ld	r28, Z
 cae:	d1 81       	ldd	r29, Z+1	; 0x01
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
 cb0:	be 01       	movw	r22, r28
 cb2:	6e 5f       	subi	r22, 0xFE	; 254
 cb4:	7f 4f       	sbci	r23, 0xFF	; 255
 cb6:	0e 94 fd 04 	call	0x9fa	; 0x9fa <osEE_scheduler_core_rq_preempt_stk>

  if (p_prev != NULL) {
 cba:	00 97       	sbiw	r24, 0x00	; 0
 cbc:	49 f0       	breq	.+18     	; 0xcd0 <osEE_scheduler_task_preemption_point+0x2c>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_prev, p_curr);
 cbe:	68 81       	ld	r22, Y
 cc0:	79 81       	ldd	r23, Y+1	; 0x01
 cc2:	0e 94 6f 06 	call	0xcde	; 0xcde <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
 cc6:	81 e0       	ldi	r24, 0x01	; 1
 cc8:	90 e0       	ldi	r25, 0x00	; 0
  } else {
    osEE_unlock_core(p_cdb);
    is_preemption = OSEE_FALSE;
  }
  return is_preemption;
}
 cca:	df 91       	pop	r29
 ccc:	cf 91       	pop	r28
 cce:	08 95       	ret
    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    osEE_unlock_core(p_cdb);
    is_preemption = OSEE_FALSE;
 cd0:	90 e0       	ldi	r25, 0x00	; 0
 cd2:	80 e0       	ldi	r24, 0x00	; 0
  }
  return is_preemption;
 cd4:	fa cf       	rjmp	.-12     	; 0xcca <osEE_scheduler_task_preemption_point+0x26>

00000cd6 <__vector_default>:
#include "ee_avr8_irqstub.h"

/* Erika Interrupt Vector Definition */

/* DUMMY interrupt vector */
OSEE_AVR8_ISR_NOT_DEFINED(BADISR_vect)
 cd6:	f8 94       	cli
 cd8:	ff cf       	rjmp	.-2      	; 0xcd8 <__vector_default+0x2>

00000cda <osEE_atmega_intvect>:

/* Interrupt Vector Table Recall. */
void osEE_atmega_intvect(void) {
  OSEE_AVR8_REQUEST_IRQ_ENTRY(BADISR_vect);
 cda:	e6 ed       	ldi	r30, 0xD6	; 214
}
 cdc:	08 95       	ret

00000cde <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
 cde:	fb 01       	movw	r30, r22
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;
 ce0:	a4 81       	ldd	r26, Z+4	; 0x04
 ce2:	b5 81       	ldd	r27, Z+5	; 0x05
  CONST(TaskStateType, AUTOMATIC)     status_prev_running = p_to_tcb->status;
 ce4:	12 96       	adiw	r26, 0x02	; 2
 ce6:	2d 91       	ld	r18, X+
 ce8:	3c 91       	ld	r19, X
 cea:	13 97       	sbiw	r26, 0x03	; 3

  p_to_tcb->status = OSEE_TASK_RUNNING;
 cec:	44 e0       	ldi	r20, 0x04	; 4
 cee:	50 e0       	ldi	r21, 0x00	; 0
 cf0:	13 96       	adiw	r26, 0x03	; 3
 cf2:	5c 93       	st	X, r21
 cf4:	4e 93       	st	-X, r20
 cf6:	12 97       	sbiw	r26, 0x02	; 2
 cf8:	dc 01       	movw	r26, r24
 cfa:	12 96       	adiw	r26, 0x02	; 2
 cfc:	4d 91       	ld	r20, X+
 cfe:	5c 91       	ld	r21, X
 d00:	62 81       	ldd	r22, Z+2	; 0x02
 d02:	73 81       	ldd	r23, Z+3	; 0x03

  if (status_prev_running == OSEE_TASK_READY_STACKED) {
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
 d04:	cf 01       	movw	r24, r30
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;
  CONST(TaskStateType, AUTOMATIC)     status_prev_running = p_to_tcb->status;

  p_to_tcb->status = OSEE_TASK_RUNNING;

  if (status_prev_running == OSEE_TASK_READY_STACKED) {
 d06:	22 30       	cpi	r18, 0x02	; 2
 d08:	31 05       	cpc	r19, r1
 d0a:	11 f4       	brne	.+4      	; 0xd10 <osEE_change_context_from_running+0x32>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
 d0c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <osEE_hal_save_ctx_and_restore_ctx>
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
 d10:	0c 94 a8 00 	jmp	0x150	; 0x150 <osEE_hal_save_ctx_and_ready2stacked>

00000d14 <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
 d14:	cb 01       	movw	r24, r22
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;
 d16:	db 01       	movw	r26, r22
 d18:	14 96       	adiw	r26, 0x04	; 4
 d1a:	ed 91       	ld	r30, X+
 d1c:	fc 91       	ld	r31, X
 d1e:	15 97       	sbiw	r26, 0x05	; 5
  CONST(TaskStateType, AUTOMATIC)     status_prev_running = p_to_tcb->status;
 d20:	22 81       	ldd	r18, Z+2	; 0x02
 d22:	33 81       	ldd	r19, Z+3	; 0x03

  p_to_tcb->status = OSEE_TASK_RUNNING;
 d24:	44 e0       	ldi	r20, 0x04	; 4
 d26:	50 e0       	ldi	r21, 0x00	; 0
 d28:	53 83       	std	Z+3, r21	; 0x03
 d2a:	42 83       	std	Z+2, r20	; 0x02
 d2c:	12 96       	adiw	r26, 0x02	; 2
 d2e:	6d 91       	ld	r22, X+
 d30:	7c 91       	ld	r23, X

  if (status_prev_running == OSEE_TASK_READY_STACKED) {
 d32:	22 30       	cpi	r18, 0x02	; 2
 d34:	31 05       	cpc	r19, r1
 d36:	11 f4       	brne	.+4      	; 0xd3c <osEE_change_context_from_task_end+0x28>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
 d38:	0c 94 80 00 	jmp	0x100	; 0x100 <osEE_hal_restore_ctx>
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
 d3c:	0c 94 a0 00 	jmp	0x140	; 0x140 <osEE_hal_ready2stacked>

00000d40 <osEE_idle_task_terminate>:
{
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
 d40:	dc 01       	movw	r26, r24
 d42:	12 96       	adiw	r26, 0x02	; 2
 d44:	6d 91       	ld	r22, X+
 d46:	7c 91       	ld	r23, X
 d48:	13 97       	sbiw	r26, 0x03	; 3
  CONSTP2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos       = p_sdb->p_bos;
 d4a:	ed 91       	ld	r30, X+
 d4c:	fc 91       	ld	r31, X
 d4e:	40 81       	ld	r20, Z
 d50:	51 81       	ldd	r21, Z+1	; 0x01
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
 d52:	db 01       	movw	r26, r22
 d54:	ed 91       	ld	r30, X+
 d56:	fc 91       	ld	r31, X

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
 d58:	22 89       	ldd	r18, Z+18	; 0x12
 d5a:	33 89       	ldd	r19, Z+19	; 0x13
  } while ((p_tos != NULL) && (p_tos != p_bos));
 d5c:	21 15       	cp	r18, r1
 d5e:	31 05       	cpc	r19, r1
 d60:	19 f0       	breq	.+6      	; 0xd68 <osEE_idle_task_terminate+0x28>
 d62:	42 17       	cp	r20, r18
 d64:	53 07       	cpc	r21, r19
 d66:	29 f4       	brne	.+10     	; 0xd72 <osEE_idle_task_terminate+0x32>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
 d68:	db 01       	movw	r26, r22
 d6a:	ed 93       	st	X+, r30
 d6c:	fc 93       	st	X, r31

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
 d6e:	0c 94 80 00 	jmp	0x100	; 0x100 <osEE_hal_restore_ctx>
 d72:	f9 01       	movw	r30, r18
 d74:	f1 cf       	rjmp	.-30     	; 0xd58 <osEE_idle_task_terminate+0x18>

00000d76 <__udivmodsi4>:
 d76:	a1 e2       	ldi	r26, 0x21	; 33
 d78:	1a 2e       	mov	r1, r26
 d7a:	aa 1b       	sub	r26, r26
 d7c:	bb 1b       	sub	r27, r27
 d7e:	fd 01       	movw	r30, r26
 d80:	0d c0       	rjmp	.+26     	; 0xd9c <__udivmodsi4_ep>

00000d82 <__udivmodsi4_loop>:
 d82:	aa 1f       	adc	r26, r26
 d84:	bb 1f       	adc	r27, r27
 d86:	ee 1f       	adc	r30, r30
 d88:	ff 1f       	adc	r31, r31
 d8a:	a2 17       	cp	r26, r18
 d8c:	b3 07       	cpc	r27, r19
 d8e:	e4 07       	cpc	r30, r20
 d90:	f5 07       	cpc	r31, r21
 d92:	20 f0       	brcs	.+8      	; 0xd9c <__udivmodsi4_ep>
 d94:	a2 1b       	sub	r26, r18
 d96:	b3 0b       	sbc	r27, r19
 d98:	e4 0b       	sbc	r30, r20
 d9a:	f5 0b       	sbc	r31, r21

00000d9c <__udivmodsi4_ep>:
 d9c:	66 1f       	adc	r22, r22
 d9e:	77 1f       	adc	r23, r23
 da0:	88 1f       	adc	r24, r24
 da2:	99 1f       	adc	r25, r25
 da4:	1a 94       	dec	r1
 da6:	69 f7       	brne	.-38     	; 0xd82 <__udivmodsi4_loop>
 da8:	60 95       	com	r22
 daa:	70 95       	com	r23
 dac:	80 95       	com	r24
 dae:	90 95       	com	r25
 db0:	9b 01       	movw	r18, r22
 db2:	ac 01       	movw	r20, r24
 db4:	bd 01       	movw	r22, r26
 db6:	cf 01       	movw	r24, r30
 db8:	08 95       	ret

00000dba <__tablejump2__>:
 dba:	ee 0f       	add	r30, r30
 dbc:	ff 1f       	adc	r31, r31
 dbe:	05 90       	lpm	r0, Z+
 dc0:	f4 91       	lpm	r31, Z
 dc2:	e0 2d       	mov	r30, r0
 dc4:	09 94       	ijmp

00000dc6 <_exit>:
 dc6:	f8 94       	cli

00000dc8 <__stop_program>:
 dc8:	ff cf       	rjmp	.-2      	; 0xdc8 <__stop_program>
